// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mixr/recorder/protobuf/DataRecord.proto

#ifndef PROTOBUF_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto__INCLUDED
#define PROTOBUF_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mixr {
namespace recorder {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

class DataRecord;
class FileIdMsg;
class UnknownIdMsg;
class MarkerMsg;
class InputDeviceMsg;
class NewPlayerEventMsg;
class PlayerRemovedEventMsg;
class PlayerDataMsg;
class PlayerDamagedEventMsg;
class PlayerCollisionEventMsg;
class PlayerCrashEventMsg;
class PlayerKilledEventMsg;
class WeaponReleaseEventMsg;
class WeaponHungEventMsg;
class WeaponDetonationEventMsg;
class GunFiredEventMsg;
class NewTrackEventMsg;
class TrackRemovedEventMsg;
class TrackDataMsg;
class Vector;
class Time;
class PlayerId;
class PlayerState;
class TrackData;
class EmissionData;

enum WeaponDetonationEventMsg_DetonationType {
  WeaponDetonationEventMsg_DetonationType_DETONATE_OTHER = 0,
  WeaponDetonationEventMsg_DetonationType_DETONATE_ENTITY_IMPACT = 1,
  WeaponDetonationEventMsg_DetonationType_DETONATE_ENTITY_PROXIMATE_DETONATION = 2,
  WeaponDetonationEventMsg_DetonationType_DETONATE_GROUND_IMPACT = 3,
  WeaponDetonationEventMsg_DetonationType_DETONATE_GROUND_PROXIMATE_DETONATION = 4,
  WeaponDetonationEventMsg_DetonationType_DETONATE_DETONATION = 5,
  WeaponDetonationEventMsg_DetonationType_DETONATE_NONE = 6
};
bool WeaponDetonationEventMsg_DetonationType_IsValid(int value);
const WeaponDetonationEventMsg_DetonationType WeaponDetonationEventMsg_DetonationType_DetonationType_MIN = WeaponDetonationEventMsg_DetonationType_DETONATE_OTHER;
const WeaponDetonationEventMsg_DetonationType WeaponDetonationEventMsg_DetonationType_DetonationType_MAX = WeaponDetonationEventMsg_DetonationType_DETONATE_NONE;
const int WeaponDetonationEventMsg_DetonationType_DetonationType_ARRAYSIZE = WeaponDetonationEventMsg_DetonationType_DetonationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WeaponDetonationEventMsg_DetonationType_descriptor();
inline const ::std::string& WeaponDetonationEventMsg_DetonationType_Name(WeaponDetonationEventMsg_DetonationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WeaponDetonationEventMsg_DetonationType_descriptor(), value);
}
inline bool WeaponDetonationEventMsg_DetonationType_Parse(
    const ::std::string& name, WeaponDetonationEventMsg_DetonationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WeaponDetonationEventMsg_DetonationType>(
    WeaponDetonationEventMsg_DetonationType_descriptor(), name, value);
}
enum EmissionData_Polarization {
  EmissionData_Polarization_NONE = 0,
  EmissionData_Polarization_VERTICAL = 1,
  EmissionData_Polarization_HORIZONTAL = 2,
  EmissionData_Polarization_SLANT = 3,
  EmissionData_Polarization_RHC = 4,
  EmissionData_Polarization_LHC = 5
};
bool EmissionData_Polarization_IsValid(int value);
const EmissionData_Polarization EmissionData_Polarization_Polarization_MIN = EmissionData_Polarization_NONE;
const EmissionData_Polarization EmissionData_Polarization_Polarization_MAX = EmissionData_Polarization_LHC;
const int EmissionData_Polarization_Polarization_ARRAYSIZE = EmissionData_Polarization_Polarization_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmissionData_Polarization_descriptor();
inline const ::std::string& EmissionData_Polarization_Name(EmissionData_Polarization value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmissionData_Polarization_descriptor(), value);
}
inline bool EmissionData_Polarization_Parse(
    const ::std::string& name, EmissionData_Polarization* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmissionData_Polarization>(
    EmissionData_Polarization_descriptor(), name, value);
}
// ===================================================================

class DataRecord : public ::google::protobuf::Message {
 public:
  DataRecord();
  virtual ~DataRecord();

  DataRecord(const DataRecord& from);

  inline DataRecord& operator=(const DataRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataRecord& default_instance();

  void Swap(DataRecord* other);

  // implements Message ----------------------------------------------

  DataRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataRecord& from);
  void MergeFrom(const DataRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.Time time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline const ::mixr::recorder::pb::Time& time() const;
  inline ::mixr::recorder::pb::Time* mutable_time();
  inline ::mixr::recorder::pb::Time* release_time();
  inline void set_allocated_time(::mixr::recorder::pb::Time* time);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .mixr.recorder.pb.FileIdMsg file_id_msg = 11;
  inline bool has_file_id_msg() const;
  inline void clear_file_id_msg();
  static const int kFileIdMsgFieldNumber = 11;
  inline const ::mixr::recorder::pb::FileIdMsg& file_id_msg() const;
  inline ::mixr::recorder::pb::FileIdMsg* mutable_file_id_msg();
  inline ::mixr::recorder::pb::FileIdMsg* release_file_id_msg();
  inline void set_allocated_file_id_msg(::mixr::recorder::pb::FileIdMsg* file_id_msg);

  // optional .mixr.recorder.pb.UnknownIdMsg unknown_id_msg = 13;
  inline bool has_unknown_id_msg() const;
  inline void clear_unknown_id_msg();
  static const int kUnknownIdMsgFieldNumber = 13;
  inline const ::mixr::recorder::pb::UnknownIdMsg& unknown_id_msg() const;
  inline ::mixr::recorder::pb::UnknownIdMsg* mutable_unknown_id_msg();
  inline ::mixr::recorder::pb::UnknownIdMsg* release_unknown_id_msg();
  inline void set_allocated_unknown_id_msg(::mixr::recorder::pb::UnknownIdMsg* unknown_id_msg);

  // optional .mixr.recorder.pb.MarkerMsg marker_msg = 14;
  inline bool has_marker_msg() const;
  inline void clear_marker_msg();
  static const int kMarkerMsgFieldNumber = 14;
  inline const ::mixr::recorder::pb::MarkerMsg& marker_msg() const;
  inline ::mixr::recorder::pb::MarkerMsg* mutable_marker_msg();
  inline ::mixr::recorder::pb::MarkerMsg* release_marker_msg();
  inline void set_allocated_marker_msg(::mixr::recorder::pb::MarkerMsg* marker_msg);

  // optional .mixr.recorder.pb.InputDeviceMsg input_device_msg = 15;
  inline bool has_input_device_msg() const;
  inline void clear_input_device_msg();
  static const int kInputDeviceMsgFieldNumber = 15;
  inline const ::mixr::recorder::pb::InputDeviceMsg& input_device_msg() const;
  inline ::mixr::recorder::pb::InputDeviceMsg* mutable_input_device_msg();
  inline ::mixr::recorder::pb::InputDeviceMsg* release_input_device_msg();
  inline void set_allocated_input_device_msg(::mixr::recorder::pb::InputDeviceMsg* input_device_msg);

  // optional .mixr.recorder.pb.NewPlayerEventMsg new_player_event_msg = 31;
  inline bool has_new_player_event_msg() const;
  inline void clear_new_player_event_msg();
  static const int kNewPlayerEventMsgFieldNumber = 31;
  inline const ::mixr::recorder::pb::NewPlayerEventMsg& new_player_event_msg() const;
  inline ::mixr::recorder::pb::NewPlayerEventMsg* mutable_new_player_event_msg();
  inline ::mixr::recorder::pb::NewPlayerEventMsg* release_new_player_event_msg();
  inline void set_allocated_new_player_event_msg(::mixr::recorder::pb::NewPlayerEventMsg* new_player_event_msg);

  // optional .mixr.recorder.pb.PlayerRemovedEventMsg player_removed_event_msg = 32;
  inline bool has_player_removed_event_msg() const;
  inline void clear_player_removed_event_msg();
  static const int kPlayerRemovedEventMsgFieldNumber = 32;
  inline const ::mixr::recorder::pb::PlayerRemovedEventMsg& player_removed_event_msg() const;
  inline ::mixr::recorder::pb::PlayerRemovedEventMsg* mutable_player_removed_event_msg();
  inline ::mixr::recorder::pb::PlayerRemovedEventMsg* release_player_removed_event_msg();
  inline void set_allocated_player_removed_event_msg(::mixr::recorder::pb::PlayerRemovedEventMsg* player_removed_event_msg);

  // optional .mixr.recorder.pb.PlayerDataMsg player_data_msg = 33;
  inline bool has_player_data_msg() const;
  inline void clear_player_data_msg();
  static const int kPlayerDataMsgFieldNumber = 33;
  inline const ::mixr::recorder::pb::PlayerDataMsg& player_data_msg() const;
  inline ::mixr::recorder::pb::PlayerDataMsg* mutable_player_data_msg();
  inline ::mixr::recorder::pb::PlayerDataMsg* release_player_data_msg();
  inline void set_allocated_player_data_msg(::mixr::recorder::pb::PlayerDataMsg* player_data_msg);

  // optional .mixr.recorder.pb.PlayerDamagedEventMsg player_damaged_event_msg = 34;
  inline bool has_player_damaged_event_msg() const;
  inline void clear_player_damaged_event_msg();
  static const int kPlayerDamagedEventMsgFieldNumber = 34;
  inline const ::mixr::recorder::pb::PlayerDamagedEventMsg& player_damaged_event_msg() const;
  inline ::mixr::recorder::pb::PlayerDamagedEventMsg* mutable_player_damaged_event_msg();
  inline ::mixr::recorder::pb::PlayerDamagedEventMsg* release_player_damaged_event_msg();
  inline void set_allocated_player_damaged_event_msg(::mixr::recorder::pb::PlayerDamagedEventMsg* player_damaged_event_msg);

  // optional .mixr.recorder.pb.PlayerCollisionEventMsg player_collision_event_msg = 35;
  inline bool has_player_collision_event_msg() const;
  inline void clear_player_collision_event_msg();
  static const int kPlayerCollisionEventMsgFieldNumber = 35;
  inline const ::mixr::recorder::pb::PlayerCollisionEventMsg& player_collision_event_msg() const;
  inline ::mixr::recorder::pb::PlayerCollisionEventMsg* mutable_player_collision_event_msg();
  inline ::mixr::recorder::pb::PlayerCollisionEventMsg* release_player_collision_event_msg();
  inline void set_allocated_player_collision_event_msg(::mixr::recorder::pb::PlayerCollisionEventMsg* player_collision_event_msg);

  // optional .mixr.recorder.pb.PlayerCrashEventMsg player_crash_event_msg = 36;
  inline bool has_player_crash_event_msg() const;
  inline void clear_player_crash_event_msg();
  static const int kPlayerCrashEventMsgFieldNumber = 36;
  inline const ::mixr::recorder::pb::PlayerCrashEventMsg& player_crash_event_msg() const;
  inline ::mixr::recorder::pb::PlayerCrashEventMsg* mutable_player_crash_event_msg();
  inline ::mixr::recorder::pb::PlayerCrashEventMsg* release_player_crash_event_msg();
  inline void set_allocated_player_crash_event_msg(::mixr::recorder::pb::PlayerCrashEventMsg* player_crash_event_msg);

  // optional .mixr.recorder.pb.PlayerKilledEventMsg player_killed_event_msg = 37;
  inline bool has_player_killed_event_msg() const;
  inline void clear_player_killed_event_msg();
  static const int kPlayerKilledEventMsgFieldNumber = 37;
  inline const ::mixr::recorder::pb::PlayerKilledEventMsg& player_killed_event_msg() const;
  inline ::mixr::recorder::pb::PlayerKilledEventMsg* mutable_player_killed_event_msg();
  inline ::mixr::recorder::pb::PlayerKilledEventMsg* release_player_killed_event_msg();
  inline void set_allocated_player_killed_event_msg(::mixr::recorder::pb::PlayerKilledEventMsg* player_killed_event_msg);

  // optional .mixr.recorder.pb.WeaponReleaseEventMsg weapon_release_event_msg = 51;
  inline bool has_weapon_release_event_msg() const;
  inline void clear_weapon_release_event_msg();
  static const int kWeaponReleaseEventMsgFieldNumber = 51;
  inline const ::mixr::recorder::pb::WeaponReleaseEventMsg& weapon_release_event_msg() const;
  inline ::mixr::recorder::pb::WeaponReleaseEventMsg* mutable_weapon_release_event_msg();
  inline ::mixr::recorder::pb::WeaponReleaseEventMsg* release_weapon_release_event_msg();
  inline void set_allocated_weapon_release_event_msg(::mixr::recorder::pb::WeaponReleaseEventMsg* weapon_release_event_msg);

  // optional .mixr.recorder.pb.WeaponHungEventMsg weapon_hung_event_msg = 52;
  inline bool has_weapon_hung_event_msg() const;
  inline void clear_weapon_hung_event_msg();
  static const int kWeaponHungEventMsgFieldNumber = 52;
  inline const ::mixr::recorder::pb::WeaponHungEventMsg& weapon_hung_event_msg() const;
  inline ::mixr::recorder::pb::WeaponHungEventMsg* mutable_weapon_hung_event_msg();
  inline ::mixr::recorder::pb::WeaponHungEventMsg* release_weapon_hung_event_msg();
  inline void set_allocated_weapon_hung_event_msg(::mixr::recorder::pb::WeaponHungEventMsg* weapon_hung_event_msg);

  // optional .mixr.recorder.pb.WeaponDetonationEventMsg weapon_detonation_event_msg = 53;
  inline bool has_weapon_detonation_event_msg() const;
  inline void clear_weapon_detonation_event_msg();
  static const int kWeaponDetonationEventMsgFieldNumber = 53;
  inline const ::mixr::recorder::pb::WeaponDetonationEventMsg& weapon_detonation_event_msg() const;
  inline ::mixr::recorder::pb::WeaponDetonationEventMsg* mutable_weapon_detonation_event_msg();
  inline ::mixr::recorder::pb::WeaponDetonationEventMsg* release_weapon_detonation_event_msg();
  inline void set_allocated_weapon_detonation_event_msg(::mixr::recorder::pb::WeaponDetonationEventMsg* weapon_detonation_event_msg);

  // optional .mixr.recorder.pb.GunFiredEventMsg gun_fired_event_msg = 54;
  inline bool has_gun_fired_event_msg() const;
  inline void clear_gun_fired_event_msg();
  static const int kGunFiredEventMsgFieldNumber = 54;
  inline const ::mixr::recorder::pb::GunFiredEventMsg& gun_fired_event_msg() const;
  inline ::mixr::recorder::pb::GunFiredEventMsg* mutable_gun_fired_event_msg();
  inline ::mixr::recorder::pb::GunFiredEventMsg* release_gun_fired_event_msg();
  inline void set_allocated_gun_fired_event_msg(::mixr::recorder::pb::GunFiredEventMsg* gun_fired_event_msg);

  // optional .mixr.recorder.pb.NewTrackEventMsg new_track_event_msg = 71;
  inline bool has_new_track_event_msg() const;
  inline void clear_new_track_event_msg();
  static const int kNewTrackEventMsgFieldNumber = 71;
  inline const ::mixr::recorder::pb::NewTrackEventMsg& new_track_event_msg() const;
  inline ::mixr::recorder::pb::NewTrackEventMsg* mutable_new_track_event_msg();
  inline ::mixr::recorder::pb::NewTrackEventMsg* release_new_track_event_msg();
  inline void set_allocated_new_track_event_msg(::mixr::recorder::pb::NewTrackEventMsg* new_track_event_msg);

  // optional .mixr.recorder.pb.TrackRemovedEventMsg track_removed_event_msg = 72;
  inline bool has_track_removed_event_msg() const;
  inline void clear_track_removed_event_msg();
  static const int kTrackRemovedEventMsgFieldNumber = 72;
  inline const ::mixr::recorder::pb::TrackRemovedEventMsg& track_removed_event_msg() const;
  inline ::mixr::recorder::pb::TrackRemovedEventMsg* mutable_track_removed_event_msg();
  inline ::mixr::recorder::pb::TrackRemovedEventMsg* release_track_removed_event_msg();
  inline void set_allocated_track_removed_event_msg(::mixr::recorder::pb::TrackRemovedEventMsg* track_removed_event_msg);

  // optional .mixr.recorder.pb.TrackDataMsg track_data_msg = 73;
  inline bool has_track_data_msg() const;
  inline void clear_track_data_msg();
  static const int kTrackDataMsgFieldNumber = 73;
  inline const ::mixr::recorder::pb::TrackDataMsg& track_data_msg() const;
  inline ::mixr::recorder::pb::TrackDataMsg* mutable_track_data_msg();
  inline ::mixr::recorder::pb::TrackDataMsg* release_track_data_msg();
  inline void set_allocated_track_data_msg(::mixr::recorder::pb::TrackDataMsg* track_data_msg);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(DataRecord)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.DataRecord)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_file_id_msg();
  inline void clear_has_file_id_msg();
  inline void set_has_unknown_id_msg();
  inline void clear_has_unknown_id_msg();
  inline void set_has_marker_msg();
  inline void clear_has_marker_msg();
  inline void set_has_input_device_msg();
  inline void clear_has_input_device_msg();
  inline void set_has_new_player_event_msg();
  inline void clear_has_new_player_event_msg();
  inline void set_has_player_removed_event_msg();
  inline void clear_has_player_removed_event_msg();
  inline void set_has_player_data_msg();
  inline void clear_has_player_data_msg();
  inline void set_has_player_damaged_event_msg();
  inline void clear_has_player_damaged_event_msg();
  inline void set_has_player_collision_event_msg();
  inline void clear_has_player_collision_event_msg();
  inline void set_has_player_crash_event_msg();
  inline void clear_has_player_crash_event_msg();
  inline void set_has_player_killed_event_msg();
  inline void clear_has_player_killed_event_msg();
  inline void set_has_weapon_release_event_msg();
  inline void clear_has_weapon_release_event_msg();
  inline void set_has_weapon_hung_event_msg();
  inline void clear_has_weapon_hung_event_msg();
  inline void set_has_weapon_detonation_event_msg();
  inline void clear_has_weapon_detonation_event_msg();
  inline void set_has_gun_fired_event_msg();
  inline void clear_has_gun_fired_event_msg();
  inline void set_has_new_track_event_msg();
  inline void clear_has_new_track_event_msg();
  inline void set_has_track_removed_event_msg();
  inline void clear_has_track_removed_event_msg();
  inline void set_has_track_data_msg();
  inline void clear_has_track_data_msg();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::Time* time_;
  ::mixr::recorder::pb::FileIdMsg* file_id_msg_;
  ::mixr::recorder::pb::UnknownIdMsg* unknown_id_msg_;
  ::mixr::recorder::pb::MarkerMsg* marker_msg_;
  ::mixr::recorder::pb::InputDeviceMsg* input_device_msg_;
  ::mixr::recorder::pb::NewPlayerEventMsg* new_player_event_msg_;
  ::mixr::recorder::pb::PlayerRemovedEventMsg* player_removed_event_msg_;
  ::mixr::recorder::pb::PlayerDataMsg* player_data_msg_;
  ::mixr::recorder::pb::PlayerDamagedEventMsg* player_damaged_event_msg_;
  ::mixr::recorder::pb::PlayerCollisionEventMsg* player_collision_event_msg_;
  ::mixr::recorder::pb::PlayerCrashEventMsg* player_crash_event_msg_;
  ::mixr::recorder::pb::PlayerKilledEventMsg* player_killed_event_msg_;
  ::mixr::recorder::pb::WeaponReleaseEventMsg* weapon_release_event_msg_;
  ::mixr::recorder::pb::WeaponHungEventMsg* weapon_hung_event_msg_;
  ::mixr::recorder::pb::WeaponDetonationEventMsg* weapon_detonation_event_msg_;
  ::mixr::recorder::pb::GunFiredEventMsg* gun_fired_event_msg_;
  ::mixr::recorder::pb::NewTrackEventMsg* new_track_event_msg_;
  ::mixr::recorder::pb::TrackRemovedEventMsg* track_removed_event_msg_;
  ::mixr::recorder::pb::TrackDataMsg* track_data_msg_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static DataRecord* default_instance_;
};
// -------------------------------------------------------------------

class FileIdMsg : public ::google::protobuf::Message {
 public:
  FileIdMsg();
  virtual ~FileIdMsg();

  FileIdMsg(const FileIdMsg& from);

  inline FileIdMsg& operator=(const FileIdMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileIdMsg& default_instance();

  void Swap(FileIdMsg* other);

  // implements Message ----------------------------------------------

  FileIdMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileIdMsg& from);
  void MergeFrom(const FileIdMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string event_name = 1;
  inline bool has_event_name() const;
  inline void clear_event_name();
  static const int kEventNameFieldNumber = 1;
  inline const ::std::string& event_name() const;
  inline void set_event_name(const ::std::string& value);
  inline void set_event_name(const char* value);
  inline void set_event_name(const char* value, size_t size);
  inline ::std::string* mutable_event_name();
  inline ::std::string* release_event_name();
  inline void set_allocated_event_name(::std::string* event_name);

  // optional string application = 2;
  inline bool has_application() const;
  inline void clear_application();
  static const int kApplicationFieldNumber = 2;
  inline const ::std::string& application() const;
  inline void set_application(const ::std::string& value);
  inline void set_application(const char* value);
  inline void set_application(const char* value, size_t size);
  inline ::std::string* mutable_application();
  inline ::std::string* release_application();
  inline void set_allocated_application(::std::string* application);

  // optional uint32 case_num = 3;
  inline bool has_case_num() const;
  inline void clear_case_num();
  static const int kCaseNumFieldNumber = 3;
  inline ::google::protobuf::uint32 case_num() const;
  inline void set_case_num(::google::protobuf::uint32 value);

  // optional uint32 mission_num = 4;
  inline bool has_mission_num() const;
  inline void clear_mission_num();
  static const int kMissionNumFieldNumber = 4;
  inline ::google::protobuf::uint32 mission_num() const;
  inline void set_mission_num(::google::protobuf::uint32 value);

  // optional uint32 subject_num = 5;
  inline bool has_subject_num() const;
  inline void clear_subject_num();
  static const int kSubjectNumFieldNumber = 5;
  inline ::google::protobuf::uint32 subject_num() const;
  inline void set_subject_num(::google::protobuf::uint32 value);

  // optional uint32 run_num = 6;
  inline bool has_run_num() const;
  inline void clear_run_num();
  static const int kRunNumFieldNumber = 6;
  inline ::google::protobuf::uint32 run_num() const;
  inline void set_run_num(::google::protobuf::uint32 value);

  // optional uint32 day = 7;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 7;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // optional uint32 month = 8;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 8;
  inline ::google::protobuf::uint32 month() const;
  inline void set_month(::google::protobuf::uint32 value);

  // optional uint32 year = 9;
  inline bool has_year() const;
  inline void clear_year();
  static const int kYearFieldNumber = 9;
  inline ::google::protobuf::uint32 year() const;
  inline void set_year(::google::protobuf::uint32 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(FileIdMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.FileIdMsg)
 private:
  inline void set_has_event_name();
  inline void clear_has_event_name();
  inline void set_has_application();
  inline void clear_has_application();
  inline void set_has_case_num();
  inline void clear_has_case_num();
  inline void set_has_mission_num();
  inline void clear_has_mission_num();
  inline void set_has_subject_num();
  inline void clear_has_subject_num();
  inline void set_has_run_num();
  inline void clear_has_run_num();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_year();
  inline void clear_has_year();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* event_name_;
  ::std::string* application_;
  ::google::protobuf::uint32 case_num_;
  ::google::protobuf::uint32 mission_num_;
  ::google::protobuf::uint32 subject_num_;
  ::google::protobuf::uint32 run_num_;
  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 month_;
  ::google::protobuf::uint32 year_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static FileIdMsg* default_instance_;
};
// -------------------------------------------------------------------

class UnknownIdMsg : public ::google::protobuf::Message {
 public:
  UnknownIdMsg();
  virtual ~UnknownIdMsg();

  UnknownIdMsg(const UnknownIdMsg& from);

  inline UnknownIdMsg& operator=(const UnknownIdMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnknownIdMsg& default_instance();

  void Swap(UnknownIdMsg* other);

  // implements Message ----------------------------------------------

  UnknownIdMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnknownIdMsg& from);
  void MergeFrom(const UnknownIdMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.UnknownIdMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static UnknownIdMsg* default_instance_;
};
// -------------------------------------------------------------------

class MarkerMsg : public ::google::protobuf::Message {
 public:
  MarkerMsg();
  virtual ~MarkerMsg();

  MarkerMsg(const MarkerMsg& from);

  inline MarkerMsg& operator=(const MarkerMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarkerMsg& default_instance();

  void Swap(MarkerMsg* other);

  // implements Message ----------------------------------------------

  MarkerMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarkerMsg& from);
  void MergeFrom(const MarkerMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 source_id = 2;
  inline bool has_source_id() const;
  inline void clear_source_id();
  static const int kSourceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 source_id() const;
  inline void set_source_id(::google::protobuf::uint32 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(MarkerMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.MarkerMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_source_id();
  inline void clear_has_source_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 source_id_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static MarkerMsg* default_instance_;
};
// -------------------------------------------------------------------

class InputDeviceMsg : public ::google::protobuf::Message {
 public:
  InputDeviceMsg();
  virtual ~InputDeviceMsg();

  InputDeviceMsg(const InputDeviceMsg& from);

  inline InputDeviceMsg& operator=(const InputDeviceMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputDeviceMsg& default_instance();

  void Swap(InputDeviceMsg* other);

  // implements Message ----------------------------------------------

  InputDeviceMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputDeviceMsg& from);
  void MergeFrom(const InputDeviceMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 source_id = 2;
  inline bool has_source_id() const;
  inline void clear_source_id();
  static const int kSourceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 source_id() const;
  inline void set_source_id(::google::protobuf::uint32 value);

  // optional float value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline float value() const;
  inline void set_value(float value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(InputDeviceMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.InputDeviceMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_source_id();
  inline void clear_has_source_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 source_id_;
  float value_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static InputDeviceMsg* default_instance_;
};
// -------------------------------------------------------------------

class NewPlayerEventMsg : public ::google::protobuf::Message {
 public:
  NewPlayerEventMsg();
  virtual ~NewPlayerEventMsg();

  NewPlayerEventMsg(const NewPlayerEventMsg& from);

  inline NewPlayerEventMsg& operator=(const NewPlayerEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewPlayerEventMsg& default_instance();

  void Swap(NewPlayerEventMsg* other);

  // implements Message ----------------------------------------------

  NewPlayerEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewPlayerEventMsg& from);
  void MergeFrom(const NewPlayerEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_id();
  inline ::mixr::recorder::pb::PlayerId* release_id();
  inline void set_allocated_id(::mixr::recorder::pb::PlayerId* id);

  // required .mixr.recorder.pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::mixr::recorder::pb::PlayerState& state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_state();
  inline ::mixr::recorder::pb::PlayerState* release_state();
  inline void set_allocated_state(::mixr::recorder::pb::PlayerState* state);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(NewPlayerEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.NewPlayerEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* id_;
  ::mixr::recorder::pb::PlayerState* state_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static NewPlayerEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerRemovedEventMsg : public ::google::protobuf::Message {
 public:
  PlayerRemovedEventMsg();
  virtual ~PlayerRemovedEventMsg();

  PlayerRemovedEventMsg(const PlayerRemovedEventMsg& from);

  inline PlayerRemovedEventMsg& operator=(const PlayerRemovedEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerRemovedEventMsg& default_instance();

  void Swap(PlayerRemovedEventMsg* other);

  // implements Message ----------------------------------------------

  PlayerRemovedEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerRemovedEventMsg& from);
  void MergeFrom(const PlayerRemovedEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_id();
  inline ::mixr::recorder::pb::PlayerId* release_id();
  inline void set_allocated_id(::mixr::recorder::pb::PlayerId* id);

  // optional .mixr.recorder.pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::mixr::recorder::pb::PlayerState& state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_state();
  inline ::mixr::recorder::pb::PlayerState* release_state();
  inline void set_allocated_state(::mixr::recorder::pb::PlayerState* state);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerRemovedEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.PlayerRemovedEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* id_;
  ::mixr::recorder::pb::PlayerState* state_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static PlayerRemovedEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerDataMsg : public ::google::protobuf::Message {
 public:
  PlayerDataMsg();
  virtual ~PlayerDataMsg();

  PlayerDataMsg(const PlayerDataMsg& from);

  inline PlayerDataMsg& operator=(const PlayerDataMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerDataMsg& default_instance();

  void Swap(PlayerDataMsg* other);

  // implements Message ----------------------------------------------

  PlayerDataMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerDataMsg& from);
  void MergeFrom(const PlayerDataMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_id();
  inline ::mixr::recorder::pb::PlayerId* release_id();
  inline void set_allocated_id(::mixr::recorder::pb::PlayerId* id);

  // required .mixr.recorder.pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::mixr::recorder::pb::PlayerState& state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_state();
  inline ::mixr::recorder::pb::PlayerState* release_state();
  inline void set_allocated_state(::mixr::recorder::pb::PlayerState* state);

  // optional double alpha = 3;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 3;
  inline double alpha() const;
  inline void set_alpha(double value);

  // optional double beta = 4;
  inline bool has_beta() const;
  inline void clear_beta();
  static const int kBetaFieldNumber = 4;
  inline double beta() const;
  inline void set_beta(double value);

  // optional double cas = 5;
  inline bool has_cas() const;
  inline void clear_cas();
  static const int kCasFieldNumber = 5;
  inline double cas() const;
  inline void set_cas(double value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerDataMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.PlayerDataMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_beta();
  inline void clear_has_beta();
  inline void set_has_cas();
  inline void clear_has_cas();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* id_;
  ::mixr::recorder::pb::PlayerState* state_;
  double alpha_;
  double beta_;
  double cas_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static PlayerDataMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerDamagedEventMsg : public ::google::protobuf::Message {
 public:
  PlayerDamagedEventMsg();
  virtual ~PlayerDamagedEventMsg();

  PlayerDamagedEventMsg(const PlayerDamagedEventMsg& from);

  inline PlayerDamagedEventMsg& operator=(const PlayerDamagedEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerDamagedEventMsg& default_instance();

  void Swap(PlayerDamagedEventMsg* other);

  // implements Message ----------------------------------------------

  PlayerDamagedEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerDamagedEventMsg& from);
  void MergeFrom(const PlayerDamagedEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_id();
  inline ::mixr::recorder::pb::PlayerId* release_id();
  inline void set_allocated_id(::mixr::recorder::pb::PlayerId* id);

  // optional .mixr.recorder.pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::mixr::recorder::pb::PlayerState& state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_state();
  inline ::mixr::recorder::pb::PlayerState* release_state();
  inline void set_allocated_state(::mixr::recorder::pb::PlayerState* state);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerDamagedEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.PlayerDamagedEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* id_;
  ::mixr::recorder::pb::PlayerState* state_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static PlayerDamagedEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCollisionEventMsg : public ::google::protobuf::Message {
 public:
  PlayerCollisionEventMsg();
  virtual ~PlayerCollisionEventMsg();

  PlayerCollisionEventMsg(const PlayerCollisionEventMsg& from);

  inline PlayerCollisionEventMsg& operator=(const PlayerCollisionEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCollisionEventMsg& default_instance();

  void Swap(PlayerCollisionEventMsg* other);

  // implements Message ----------------------------------------------

  PlayerCollisionEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCollisionEventMsg& from);
  void MergeFrom(const PlayerCollisionEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_id();
  inline ::mixr::recorder::pb::PlayerId* release_id();
  inline void set_allocated_id(::mixr::recorder::pb::PlayerId* id);

  // optional .mixr.recorder.pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::mixr::recorder::pb::PlayerState& state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_state();
  inline ::mixr::recorder::pb::PlayerState* release_state();
  inline void set_allocated_state(::mixr::recorder::pb::PlayerState* state);

  // optional .mixr.recorder.pb.PlayerId other_player_id = 3;
  inline bool has_other_player_id() const;
  inline void clear_other_player_id();
  static const int kOtherPlayerIdFieldNumber = 3;
  inline const ::mixr::recorder::pb::PlayerId& other_player_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_other_player_id();
  inline ::mixr::recorder::pb::PlayerId* release_other_player_id();
  inline void set_allocated_other_player_id(::mixr::recorder::pb::PlayerId* other_player_id);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerCollisionEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.PlayerCollisionEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_other_player_id();
  inline void clear_has_other_player_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* id_;
  ::mixr::recorder::pb::PlayerState* state_;
  ::mixr::recorder::pb::PlayerId* other_player_id_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static PlayerCollisionEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCrashEventMsg : public ::google::protobuf::Message {
 public:
  PlayerCrashEventMsg();
  virtual ~PlayerCrashEventMsg();

  PlayerCrashEventMsg(const PlayerCrashEventMsg& from);

  inline PlayerCrashEventMsg& operator=(const PlayerCrashEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCrashEventMsg& default_instance();

  void Swap(PlayerCrashEventMsg* other);

  // implements Message ----------------------------------------------

  PlayerCrashEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCrashEventMsg& from);
  void MergeFrom(const PlayerCrashEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_id();
  inline ::mixr::recorder::pb::PlayerId* release_id();
  inline void set_allocated_id(::mixr::recorder::pb::PlayerId* id);

  // optional .mixr.recorder.pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::mixr::recorder::pb::PlayerState& state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_state();
  inline ::mixr::recorder::pb::PlayerState* release_state();
  inline void set_allocated_state(::mixr::recorder::pb::PlayerState* state);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerCrashEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.PlayerCrashEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* id_;
  ::mixr::recorder::pb::PlayerState* state_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static PlayerCrashEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlayerKilledEventMsg : public ::google::protobuf::Message {
 public:
  PlayerKilledEventMsg();
  virtual ~PlayerKilledEventMsg();

  PlayerKilledEventMsg(const PlayerKilledEventMsg& from);

  inline PlayerKilledEventMsg& operator=(const PlayerKilledEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerKilledEventMsg& default_instance();

  void Swap(PlayerKilledEventMsg* other);

  // implements Message ----------------------------------------------

  PlayerKilledEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerKilledEventMsg& from);
  void MergeFrom(const PlayerKilledEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_id();
  inline ::mixr::recorder::pb::PlayerId* release_id();
  inline void set_allocated_id(::mixr::recorder::pb::PlayerId* id);

  // optional .mixr.recorder.pb.PlayerState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::mixr::recorder::pb::PlayerState& state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_state();
  inline ::mixr::recorder::pb::PlayerState* release_state();
  inline void set_allocated_state(::mixr::recorder::pb::PlayerState* state);

  // optional .mixr.recorder.pb.PlayerId shooter_id = 3;
  inline bool has_shooter_id() const;
  inline void clear_shooter_id();
  static const int kShooterIdFieldNumber = 3;
  inline const ::mixr::recorder::pb::PlayerId& shooter_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_shooter_id();
  inline ::mixr::recorder::pb::PlayerId* release_shooter_id();
  inline void set_allocated_shooter_id(::mixr::recorder::pb::PlayerId* shooter_id);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerKilledEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.PlayerKilledEventMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_shooter_id();
  inline void clear_has_shooter_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* id_;
  ::mixr::recorder::pb::PlayerState* state_;
  ::mixr::recorder::pb::PlayerId* shooter_id_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static PlayerKilledEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class WeaponReleaseEventMsg : public ::google::protobuf::Message {
 public:
  WeaponReleaseEventMsg();
  virtual ~WeaponReleaseEventMsg();

  WeaponReleaseEventMsg(const WeaponReleaseEventMsg& from);

  inline WeaponReleaseEventMsg& operator=(const WeaponReleaseEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponReleaseEventMsg& default_instance();

  void Swap(WeaponReleaseEventMsg* other);

  // implements Message ----------------------------------------------

  WeaponReleaseEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponReleaseEventMsg& from);
  void MergeFrom(const WeaponReleaseEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId wpn_id = 1;
  inline bool has_wpn_id() const;
  inline void clear_wpn_id();
  static const int kWpnIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& wpn_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_wpn_id();
  inline ::mixr::recorder::pb::PlayerId* release_wpn_id();
  inline void set_allocated_wpn_id(::mixr::recorder::pb::PlayerId* wpn_id);

  // optional .mixr.recorder.pb.PlayerState wpn_state = 2;
  inline bool has_wpn_state() const;
  inline void clear_wpn_state();
  static const int kWpnStateFieldNumber = 2;
  inline const ::mixr::recorder::pb::PlayerState& wpn_state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_wpn_state();
  inline ::mixr::recorder::pb::PlayerState* release_wpn_state();
  inline void set_allocated_wpn_state(::mixr::recorder::pb::PlayerState* wpn_state);

  // optional .mixr.recorder.pb.PlayerId shooter_id = 3;
  inline bool has_shooter_id() const;
  inline void clear_shooter_id();
  static const int kShooterIdFieldNumber = 3;
  inline const ::mixr::recorder::pb::PlayerId& shooter_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_shooter_id();
  inline ::mixr::recorder::pb::PlayerId* release_shooter_id();
  inline void set_allocated_shooter_id(::mixr::recorder::pb::PlayerId* shooter_id);

  // optional .mixr.recorder.pb.PlayerId tgt_id = 4;
  inline bool has_tgt_id() const;
  inline void clear_tgt_id();
  static const int kTgtIdFieldNumber = 4;
  inline const ::mixr::recorder::pb::PlayerId& tgt_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_tgt_id();
  inline ::mixr::recorder::pb::PlayerId* release_tgt_id();
  inline void set_allocated_tgt_id(::mixr::recorder::pb::PlayerId* tgt_id);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(WeaponReleaseEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.WeaponReleaseEventMsg)
 private:
  inline void set_has_wpn_id();
  inline void clear_has_wpn_id();
  inline void set_has_wpn_state();
  inline void clear_has_wpn_state();
  inline void set_has_shooter_id();
  inline void clear_has_shooter_id();
  inline void set_has_tgt_id();
  inline void clear_has_tgt_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* wpn_id_;
  ::mixr::recorder::pb::PlayerState* wpn_state_;
  ::mixr::recorder::pb::PlayerId* shooter_id_;
  ::mixr::recorder::pb::PlayerId* tgt_id_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static WeaponReleaseEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class WeaponHungEventMsg : public ::google::protobuf::Message {
 public:
  WeaponHungEventMsg();
  virtual ~WeaponHungEventMsg();

  WeaponHungEventMsg(const WeaponHungEventMsg& from);

  inline WeaponHungEventMsg& operator=(const WeaponHungEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponHungEventMsg& default_instance();

  void Swap(WeaponHungEventMsg* other);

  // implements Message ----------------------------------------------

  WeaponHungEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponHungEventMsg& from);
  void MergeFrom(const WeaponHungEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId wpn_id = 1;
  inline bool has_wpn_id() const;
  inline void clear_wpn_id();
  static const int kWpnIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& wpn_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_wpn_id();
  inline ::mixr::recorder::pb::PlayerId* release_wpn_id();
  inline void set_allocated_wpn_id(::mixr::recorder::pb::PlayerId* wpn_id);

  // optional .mixr.recorder.pb.PlayerState wpn_state = 2;
  inline bool has_wpn_state() const;
  inline void clear_wpn_state();
  static const int kWpnStateFieldNumber = 2;
  inline const ::mixr::recorder::pb::PlayerState& wpn_state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_wpn_state();
  inline ::mixr::recorder::pb::PlayerState* release_wpn_state();
  inline void set_allocated_wpn_state(::mixr::recorder::pb::PlayerState* wpn_state);

  // optional .mixr.recorder.pb.PlayerId shooter_id = 3;
  inline bool has_shooter_id() const;
  inline void clear_shooter_id();
  static const int kShooterIdFieldNumber = 3;
  inline const ::mixr::recorder::pb::PlayerId& shooter_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_shooter_id();
  inline ::mixr::recorder::pb::PlayerId* release_shooter_id();
  inline void set_allocated_shooter_id(::mixr::recorder::pb::PlayerId* shooter_id);

  // optional .mixr.recorder.pb.PlayerId tgt_id = 4;
  inline bool has_tgt_id() const;
  inline void clear_tgt_id();
  static const int kTgtIdFieldNumber = 4;
  inline const ::mixr::recorder::pb::PlayerId& tgt_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_tgt_id();
  inline ::mixr::recorder::pb::PlayerId* release_tgt_id();
  inline void set_allocated_tgt_id(::mixr::recorder::pb::PlayerId* tgt_id);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(WeaponHungEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.WeaponHungEventMsg)
 private:
  inline void set_has_wpn_id();
  inline void clear_has_wpn_id();
  inline void set_has_wpn_state();
  inline void clear_has_wpn_state();
  inline void set_has_shooter_id();
  inline void clear_has_shooter_id();
  inline void set_has_tgt_id();
  inline void clear_has_tgt_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* wpn_id_;
  ::mixr::recorder::pb::PlayerState* wpn_state_;
  ::mixr::recorder::pb::PlayerId* shooter_id_;
  ::mixr::recorder::pb::PlayerId* tgt_id_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static WeaponHungEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class WeaponDetonationEventMsg : public ::google::protobuf::Message {
 public:
  WeaponDetonationEventMsg();
  virtual ~WeaponDetonationEventMsg();

  WeaponDetonationEventMsg(const WeaponDetonationEventMsg& from);

  inline WeaponDetonationEventMsg& operator=(const WeaponDetonationEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponDetonationEventMsg& default_instance();

  void Swap(WeaponDetonationEventMsg* other);

  // implements Message ----------------------------------------------

  WeaponDetonationEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponDetonationEventMsg& from);
  void MergeFrom(const WeaponDetonationEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef WeaponDetonationEventMsg_DetonationType DetonationType;
  static const DetonationType DETONATE_OTHER = WeaponDetonationEventMsg_DetonationType_DETONATE_OTHER;
  static const DetonationType DETONATE_ENTITY_IMPACT = WeaponDetonationEventMsg_DetonationType_DETONATE_ENTITY_IMPACT;
  static const DetonationType DETONATE_ENTITY_PROXIMATE_DETONATION = WeaponDetonationEventMsg_DetonationType_DETONATE_ENTITY_PROXIMATE_DETONATION;
  static const DetonationType DETONATE_GROUND_IMPACT = WeaponDetonationEventMsg_DetonationType_DETONATE_GROUND_IMPACT;
  static const DetonationType DETONATE_GROUND_PROXIMATE_DETONATION = WeaponDetonationEventMsg_DetonationType_DETONATE_GROUND_PROXIMATE_DETONATION;
  static const DetonationType DETONATE_DETONATION = WeaponDetonationEventMsg_DetonationType_DETONATE_DETONATION;
  static const DetonationType DETONATE_NONE = WeaponDetonationEventMsg_DetonationType_DETONATE_NONE;
  static inline bool DetonationType_IsValid(int value) {
    return WeaponDetonationEventMsg_DetonationType_IsValid(value);
  }
  static const DetonationType DetonationType_MIN =
    WeaponDetonationEventMsg_DetonationType_DetonationType_MIN;
  static const DetonationType DetonationType_MAX =
    WeaponDetonationEventMsg_DetonationType_DetonationType_MAX;
  static const int DetonationType_ARRAYSIZE =
    WeaponDetonationEventMsg_DetonationType_DetonationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DetonationType_descriptor() {
    return WeaponDetonationEventMsg_DetonationType_descriptor();
  }
  static inline const ::std::string& DetonationType_Name(DetonationType value) {
    return WeaponDetonationEventMsg_DetonationType_Name(value);
  }
  static inline bool DetonationType_Parse(const ::std::string& name,
      DetonationType* value) {
    return WeaponDetonationEventMsg_DetonationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId wpn_id = 1;
  inline bool has_wpn_id() const;
  inline void clear_wpn_id();
  static const int kWpnIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& wpn_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_wpn_id();
  inline ::mixr::recorder::pb::PlayerId* release_wpn_id();
  inline void set_allocated_wpn_id(::mixr::recorder::pb::PlayerId* wpn_id);

  // optional .mixr.recorder.pb.PlayerState wpn_state = 2;
  inline bool has_wpn_state() const;
  inline void clear_wpn_state();
  static const int kWpnStateFieldNumber = 2;
  inline const ::mixr::recorder::pb::PlayerState& wpn_state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_wpn_state();
  inline ::mixr::recorder::pb::PlayerState* release_wpn_state();
  inline void set_allocated_wpn_state(::mixr::recorder::pb::PlayerState* wpn_state);

  // optional .mixr.recorder.pb.PlayerId shooter_id = 3;
  inline bool has_shooter_id() const;
  inline void clear_shooter_id();
  static const int kShooterIdFieldNumber = 3;
  inline const ::mixr::recorder::pb::PlayerId& shooter_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_shooter_id();
  inline ::mixr::recorder::pb::PlayerId* release_shooter_id();
  inline void set_allocated_shooter_id(::mixr::recorder::pb::PlayerId* shooter_id);

  // optional .mixr.recorder.pb.PlayerId tgt_id = 4;
  inline bool has_tgt_id() const;
  inline void clear_tgt_id();
  static const int kTgtIdFieldNumber = 4;
  inline const ::mixr::recorder::pb::PlayerId& tgt_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_tgt_id();
  inline ::mixr::recorder::pb::PlayerId* release_tgt_id();
  inline void set_allocated_tgt_id(::mixr::recorder::pb::PlayerId* tgt_id);

  // optional .mixr.recorder.pb.WeaponDetonationEventMsg.DetonationType det_type = 5;
  inline bool has_det_type() const;
  inline void clear_det_type();
  static const int kDetTypeFieldNumber = 5;
  inline ::mixr::recorder::pb::WeaponDetonationEventMsg_DetonationType det_type() const;
  inline void set_det_type(::mixr::recorder::pb::WeaponDetonationEventMsg_DetonationType value);

  // optional double miss_dist = 6;
  inline bool has_miss_dist() const;
  inline void clear_miss_dist();
  static const int kMissDistFieldNumber = 6;
  inline double miss_dist() const;
  inline void set_miss_dist(double value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(WeaponDetonationEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.WeaponDetonationEventMsg)
 private:
  inline void set_has_wpn_id();
  inline void clear_has_wpn_id();
  inline void set_has_wpn_state();
  inline void clear_has_wpn_state();
  inline void set_has_shooter_id();
  inline void clear_has_shooter_id();
  inline void set_has_tgt_id();
  inline void clear_has_tgt_id();
  inline void set_has_det_type();
  inline void clear_has_det_type();
  inline void set_has_miss_dist();
  inline void clear_has_miss_dist();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* wpn_id_;
  ::mixr::recorder::pb::PlayerState* wpn_state_;
  ::mixr::recorder::pb::PlayerId* shooter_id_;
  ::mixr::recorder::pb::PlayerId* tgt_id_;
  double miss_dist_;
  int det_type_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static WeaponDetonationEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class GunFiredEventMsg : public ::google::protobuf::Message {
 public:
  GunFiredEventMsg();
  virtual ~GunFiredEventMsg();

  GunFiredEventMsg(const GunFiredEventMsg& from);

  inline GunFiredEventMsg& operator=(const GunFiredEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GunFiredEventMsg& default_instance();

  void Swap(GunFiredEventMsg* other);

  // implements Message ----------------------------------------------

  GunFiredEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GunFiredEventMsg& from);
  void MergeFrom(const GunFiredEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId shooter_id = 1;
  inline bool has_shooter_id() const;
  inline void clear_shooter_id();
  static const int kShooterIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& shooter_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_shooter_id();
  inline ::mixr::recorder::pb::PlayerId* release_shooter_id();
  inline void set_allocated_shooter_id(::mixr::recorder::pb::PlayerId* shooter_id);

  // optional uint32 rounds = 2;
  inline bool has_rounds() const;
  inline void clear_rounds();
  static const int kRoundsFieldNumber = 2;
  inline ::google::protobuf::uint32 rounds() const;
  inline void set_rounds(::google::protobuf::uint32 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(GunFiredEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.GunFiredEventMsg)
 private:
  inline void set_has_shooter_id();
  inline void clear_has_shooter_id();
  inline void set_has_rounds();
  inline void clear_has_rounds();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* shooter_id_;
  ::google::protobuf::uint32 rounds_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static GunFiredEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class NewTrackEventMsg : public ::google::protobuf::Message {
 public:
  NewTrackEventMsg();
  virtual ~NewTrackEventMsg();

  NewTrackEventMsg(const NewTrackEventMsg& from);

  inline NewTrackEventMsg& operator=(const NewTrackEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewTrackEventMsg& default_instance();

  void Swap(NewTrackEventMsg* other);

  // implements Message ----------------------------------------------

  NewTrackEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewTrackEventMsg& from);
  void MergeFrom(const NewTrackEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& player_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_player_id();
  inline ::mixr::recorder::pb::PlayerId* release_player_id();
  inline void set_allocated_player_id(::mixr::recorder::pb::PlayerId* player_id);

  // required string track_id = 2;
  inline bool has_track_id() const;
  inline void clear_track_id();
  static const int kTrackIdFieldNumber = 2;
  inline const ::std::string& track_id() const;
  inline void set_track_id(const ::std::string& value);
  inline void set_track_id(const char* value);
  inline void set_track_id(const char* value, size_t size);
  inline ::std::string* mutable_track_id();
  inline ::std::string* release_track_id();
  inline void set_allocated_track_id(::std::string* track_id);

  // optional .mixr.recorder.pb.TrackData track_data = 3;
  inline bool has_track_data() const;
  inline void clear_track_data();
  static const int kTrackDataFieldNumber = 3;
  inline const ::mixr::recorder::pb::TrackData& track_data() const;
  inline ::mixr::recorder::pb::TrackData* mutable_track_data();
  inline ::mixr::recorder::pb::TrackData* release_track_data();
  inline void set_allocated_track_data(::mixr::recorder::pb::TrackData* track_data);

  // optional .mixr.recorder.pb.PlayerState player_state = 4;
  inline bool has_player_state() const;
  inline void clear_player_state();
  static const int kPlayerStateFieldNumber = 4;
  inline const ::mixr::recorder::pb::PlayerState& player_state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_player_state();
  inline ::mixr::recorder::pb::PlayerState* release_player_state();
  inline void set_allocated_player_state(::mixr::recorder::pb::PlayerState* player_state);

  // optional .mixr.recorder.pb.PlayerId trk_player_id = 5;
  inline bool has_trk_player_id() const;
  inline void clear_trk_player_id();
  static const int kTrkPlayerIdFieldNumber = 5;
  inline const ::mixr::recorder::pb::PlayerId& trk_player_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_trk_player_id();
  inline ::mixr::recorder::pb::PlayerId* release_trk_player_id();
  inline void set_allocated_trk_player_id(::mixr::recorder::pb::PlayerId* trk_player_id);

  // optional .mixr.recorder.pb.PlayerState trk_player_state = 6;
  inline bool has_trk_player_state() const;
  inline void clear_trk_player_state();
  static const int kTrkPlayerStateFieldNumber = 6;
  inline const ::mixr::recorder::pb::PlayerState& trk_player_state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_trk_player_state();
  inline ::mixr::recorder::pb::PlayerState* release_trk_player_state();
  inline void set_allocated_trk_player_state(::mixr::recorder::pb::PlayerState* trk_player_state);

  // optional .mixr.recorder.pb.EmissionData emission_data = 7;
  inline bool has_emission_data() const;
  inline void clear_emission_data();
  static const int kEmissionDataFieldNumber = 7;
  inline const ::mixr::recorder::pb::EmissionData& emission_data() const;
  inline ::mixr::recorder::pb::EmissionData* mutable_emission_data();
  inline ::mixr::recorder::pb::EmissionData* release_emission_data();
  inline void set_allocated_emission_data(::mixr::recorder::pb::EmissionData* emission_data);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(NewTrackEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.NewTrackEventMsg)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_track_id();
  inline void clear_has_track_id();
  inline void set_has_track_data();
  inline void clear_has_track_data();
  inline void set_has_player_state();
  inline void clear_has_player_state();
  inline void set_has_trk_player_id();
  inline void clear_has_trk_player_id();
  inline void set_has_trk_player_state();
  inline void clear_has_trk_player_state();
  inline void set_has_emission_data();
  inline void clear_has_emission_data();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* player_id_;
  ::std::string* track_id_;
  ::mixr::recorder::pb::TrackData* track_data_;
  ::mixr::recorder::pb::PlayerState* player_state_;
  ::mixr::recorder::pb::PlayerId* trk_player_id_;
  ::mixr::recorder::pb::PlayerState* trk_player_state_;
  ::mixr::recorder::pb::EmissionData* emission_data_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static NewTrackEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class TrackRemovedEventMsg : public ::google::protobuf::Message {
 public:
  TrackRemovedEventMsg();
  virtual ~TrackRemovedEventMsg();

  TrackRemovedEventMsg(const TrackRemovedEventMsg& from);

  inline TrackRemovedEventMsg& operator=(const TrackRemovedEventMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackRemovedEventMsg& default_instance();

  void Swap(TrackRemovedEventMsg* other);

  // implements Message ----------------------------------------------

  TrackRemovedEventMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackRemovedEventMsg& from);
  void MergeFrom(const TrackRemovedEventMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& player_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_player_id();
  inline ::mixr::recorder::pb::PlayerId* release_player_id();
  inline void set_allocated_player_id(::mixr::recorder::pb::PlayerId* player_id);

  // required string track_id = 2;
  inline bool has_track_id() const;
  inline void clear_track_id();
  static const int kTrackIdFieldNumber = 2;
  inline const ::std::string& track_id() const;
  inline void set_track_id(const ::std::string& value);
  inline void set_track_id(const char* value);
  inline void set_track_id(const char* value, size_t size);
  inline ::std::string* mutable_track_id();
  inline ::std::string* release_track_id();
  inline void set_allocated_track_id(::std::string* track_id);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TrackRemovedEventMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.TrackRemovedEventMsg)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_track_id();
  inline void clear_has_track_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* player_id_;
  ::std::string* track_id_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static TrackRemovedEventMsg* default_instance_;
};
// -------------------------------------------------------------------

class TrackDataMsg : public ::google::protobuf::Message {
 public:
  TrackDataMsg();
  virtual ~TrackDataMsg();

  TrackDataMsg(const TrackDataMsg& from);

  inline TrackDataMsg& operator=(const TrackDataMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackDataMsg& default_instance();

  void Swap(TrackDataMsg* other);

  // implements Message ----------------------------------------------

  TrackDataMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackDataMsg& from);
  void MergeFrom(const TrackDataMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.PlayerId player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::mixr::recorder::pb::PlayerId& player_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_player_id();
  inline ::mixr::recorder::pb::PlayerId* release_player_id();
  inline void set_allocated_player_id(::mixr::recorder::pb::PlayerId* player_id);

  // required string track_id = 2;
  inline bool has_track_id() const;
  inline void clear_track_id();
  static const int kTrackIdFieldNumber = 2;
  inline const ::std::string& track_id() const;
  inline void set_track_id(const ::std::string& value);
  inline void set_track_id(const char* value);
  inline void set_track_id(const char* value, size_t size);
  inline ::std::string* mutable_track_id();
  inline ::std::string* release_track_id();
  inline void set_allocated_track_id(::std::string* track_id);

  // optional .mixr.recorder.pb.TrackData track_data = 3;
  inline bool has_track_data() const;
  inline void clear_track_data();
  static const int kTrackDataFieldNumber = 3;
  inline const ::mixr::recorder::pb::TrackData& track_data() const;
  inline ::mixr::recorder::pb::TrackData* mutable_track_data();
  inline ::mixr::recorder::pb::TrackData* release_track_data();
  inline void set_allocated_track_data(::mixr::recorder::pb::TrackData* track_data);

  // optional .mixr.recorder.pb.PlayerState player_state = 4;
  inline bool has_player_state() const;
  inline void clear_player_state();
  static const int kPlayerStateFieldNumber = 4;
  inline const ::mixr::recorder::pb::PlayerState& player_state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_player_state();
  inline ::mixr::recorder::pb::PlayerState* release_player_state();
  inline void set_allocated_player_state(::mixr::recorder::pb::PlayerState* player_state);

  // optional .mixr.recorder.pb.PlayerId trk_player_id = 5;
  inline bool has_trk_player_id() const;
  inline void clear_trk_player_id();
  static const int kTrkPlayerIdFieldNumber = 5;
  inline const ::mixr::recorder::pb::PlayerId& trk_player_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_trk_player_id();
  inline ::mixr::recorder::pb::PlayerId* release_trk_player_id();
  inline void set_allocated_trk_player_id(::mixr::recorder::pb::PlayerId* trk_player_id);

  // optional .mixr.recorder.pb.PlayerState trk_player_state = 6;
  inline bool has_trk_player_state() const;
  inline void clear_trk_player_state();
  static const int kTrkPlayerStateFieldNumber = 6;
  inline const ::mixr::recorder::pb::PlayerState& trk_player_state() const;
  inline ::mixr::recorder::pb::PlayerState* mutable_trk_player_state();
  inline ::mixr::recorder::pb::PlayerState* release_trk_player_state();
  inline void set_allocated_trk_player_state(::mixr::recorder::pb::PlayerState* trk_player_state);

  // optional .mixr.recorder.pb.EmissionData emission_data = 7;
  inline bool has_emission_data() const;
  inline void clear_emission_data();
  static const int kEmissionDataFieldNumber = 7;
  inline const ::mixr::recorder::pb::EmissionData& emission_data() const;
  inline ::mixr::recorder::pb::EmissionData* mutable_emission_data();
  inline ::mixr::recorder::pb::EmissionData* release_emission_data();
  inline void set_allocated_emission_data(::mixr::recorder::pb::EmissionData* emission_data);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TrackDataMsg)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.TrackDataMsg)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_track_id();
  inline void clear_has_track_id();
  inline void set_has_track_data();
  inline void clear_has_track_data();
  inline void set_has_player_state();
  inline void clear_has_player_state();
  inline void set_has_trk_player_id();
  inline void clear_has_trk_player_id();
  inline void set_has_trk_player_state();
  inline void clear_has_trk_player_state();
  inline void set_has_emission_data();
  inline void clear_has_emission_data();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::PlayerId* player_id_;
  ::std::string* track_id_;
  ::mixr::recorder::pb::TrackData* track_data_;
  ::mixr::recorder::pb::PlayerState* player_state_;
  ::mixr::recorder::pb::PlayerId* trk_player_id_;
  ::mixr::recorder::pb::PlayerState* trk_player_state_;
  ::mixr::recorder::pb::EmissionData* emission_data_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static TrackDataMsg* default_instance_;
};
// -------------------------------------------------------------------

class Vector : public ::google::protobuf::Message {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();

  void Swap(Vector* other);

  // implements Message ----------------------------------------------

  Vector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // optional double w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline double w() const;
  inline void set_w(double value);

  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.Vector)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  void Swap(Time* other);

  // implements Message ----------------------------------------------

  Time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double sim_time = 1;
  inline bool has_sim_time() const;
  inline void clear_sim_time();
  static const int kSimTimeFieldNumber = 1;
  inline double sim_time() const;
  inline void set_sim_time(double value);

  // optional double exec_time = 2;
  inline bool has_exec_time() const;
  inline void clear_exec_time();
  static const int kExecTimeFieldNumber = 2;
  inline double exec_time() const;
  inline void set_exec_time(double value);

  // optional double utc_time = 3;
  inline bool has_utc_time() const;
  inline void clear_utc_time();
  static const int kUtcTimeFieldNumber = 3;
  inline double utc_time() const;
  inline void set_utc_time(double value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Time)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.Time)
 private:
  inline void set_has_sim_time();
  inline void clear_has_sim_time();
  inline void set_has_exec_time();
  inline void clear_has_exec_time();
  inline void set_has_utc_time();
  inline void clear_has_utc_time();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double sim_time_;
  double exec_time_;
  double utc_time_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static Time* default_instance_;
};
// -------------------------------------------------------------------

class PlayerId : public ::google::protobuf::Message {
 public:
  PlayerId();
  virtual ~PlayerId();

  PlayerId(const PlayerId& from);

  inline PlayerId& operator=(const PlayerId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerId& default_instance();

  void Swap(PlayerId* other);

  // implements Message ----------------------------------------------

  PlayerId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerId& from);
  void MergeFrom(const PlayerId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string fed_name = 3;
  inline bool has_fed_name() const;
  inline void clear_fed_name();
  static const int kFedNameFieldNumber = 3;
  inline const ::std::string& fed_name() const;
  inline void set_fed_name(const ::std::string& value);
  inline void set_fed_name(const char* value);
  inline void set_fed_name(const char* value, size_t size);
  inline ::std::string* mutable_fed_name();
  inline ::std::string* release_fed_name();
  inline void set_allocated_fed_name(::std::string* fed_name);

  // optional uint32 side = 4;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 4;
  inline ::google::protobuf::uint32 side() const;
  inline void set_side(::google::protobuf::uint32 value);

  // optional uint32 major_type = 5;
  inline bool has_major_type() const;
  inline void clear_major_type();
  static const int kMajorTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 major_type() const;
  inline void set_major_type(::google::protobuf::uint32 value);

  // optional string ac_type = 6;
  inline bool has_ac_type() const;
  inline void clear_ac_type();
  static const int kAcTypeFieldNumber = 6;
  inline const ::std::string& ac_type() const;
  inline void set_ac_type(const ::std::string& value);
  inline void set_ac_type(const char* value);
  inline void set_ac_type(const char* value, size_t size);
  inline ::std::string* mutable_ac_type();
  inline ::std::string* release_ac_type();
  inline void set_allocated_ac_type(::std::string* ac_type);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerId)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.PlayerId)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fed_name();
  inline void clear_has_fed_name();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_major_type();
  inline void clear_has_major_type();
  inline void set_has_ac_type();
  inline void clear_has_ac_type();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 side_;
  ::std::string* fed_name_;
  ::std::string* ac_type_;
  ::google::protobuf::uint32 major_type_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static PlayerId* default_instance_;
};
// -------------------------------------------------------------------

class PlayerState : public ::google::protobuf::Message {
 public:
  PlayerState();
  virtual ~PlayerState();

  PlayerState(const PlayerState& from);

  inline PlayerState& operator=(const PlayerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerState& default_instance();

  void Swap(PlayerState* other);

  // implements Message ----------------------------------------------

  PlayerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerState& from);
  void MergeFrom(const PlayerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mixr.recorder.pb.Vector pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::mixr::recorder::pb::Vector& pos() const;
  inline ::mixr::recorder::pb::Vector* mutable_pos();
  inline ::mixr::recorder::pb::Vector* release_pos();
  inline void set_allocated_pos(::mixr::recorder::pb::Vector* pos);

  // required .mixr.recorder.pb.Vector angles = 2;
  inline bool has_angles() const;
  inline void clear_angles();
  static const int kAnglesFieldNumber = 2;
  inline const ::mixr::recorder::pb::Vector& angles() const;
  inline ::mixr::recorder::pb::Vector* mutable_angles();
  inline ::mixr::recorder::pb::Vector* release_angles();
  inline void set_allocated_angles(::mixr::recorder::pb::Vector* angles);

  // optional .mixr.recorder.pb.Vector vel = 3;
  inline bool has_vel() const;
  inline void clear_vel();
  static const int kVelFieldNumber = 3;
  inline const ::mixr::recorder::pb::Vector& vel() const;
  inline ::mixr::recorder::pb::Vector* mutable_vel();
  inline ::mixr::recorder::pb::Vector* release_vel();
  inline void set_allocated_vel(::mixr::recorder::pb::Vector* vel);

  // optional double damage = 4;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 4;
  inline double damage() const;
  inline void set_damage(double value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(PlayerState)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.PlayerState)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_angles();
  inline void clear_has_angles();
  inline void set_has_vel();
  inline void clear_has_vel();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mixr::recorder::pb::Vector* pos_;
  ::mixr::recorder::pb::Vector* angles_;
  ::mixr::recorder::pb::Vector* vel_;
  double damage_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static PlayerState* default_instance_;
};
// -------------------------------------------------------------------

class TrackData : public ::google::protobuf::Message {
 public:
  TrackData();
  virtual ~TrackData();

  TrackData(const TrackData& from);

  inline TrackData& operator=(const TrackData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackData& default_instance();

  void Swap(TrackData* other);

  // implements Message ----------------------------------------------

  TrackData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackData& from);
  void MergeFrom(const TrackData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional double quality = 2;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 2;
  inline double quality() const;
  inline void set_quality(double value);

  // optional double true_az = 3;
  inline bool has_true_az() const;
  inline void clear_true_az();
  static const int kTrueAzFieldNumber = 3;
  inline double true_az() const;
  inline void set_true_az(double value);

  // optional double rel_az = 4;
  inline bool has_rel_az() const;
  inline void clear_rel_az();
  static const int kRelAzFieldNumber = 4;
  inline double rel_az() const;
  inline void set_rel_az(double value);

  // optional double elevation = 5;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 5;
  inline double elevation() const;
  inline void set_elevation(double value);

  // optional double range = 6;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 6;
  inline double range() const;
  inline void set_range(double value);

  // optional double latitude = 7;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 7;
  inline double latitude() const;
  inline void set_latitude(double value);

  // optional double longitude = 8;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 8;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional double altitude = 9;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 9;
  inline double altitude() const;
  inline void set_altitude(double value);

  // optional .mixr.recorder.pb.Vector position = 10;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 10;
  inline const ::mixr::recorder::pb::Vector& position() const;
  inline ::mixr::recorder::pb::Vector* mutable_position();
  inline ::mixr::recorder::pb::Vector* release_position();
  inline void set_allocated_position(::mixr::recorder::pb::Vector* position);

  // optional .mixr.recorder.pb.Vector velocity = 11;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 11;
  inline const ::mixr::recorder::pb::Vector& velocity() const;
  inline ::mixr::recorder::pb::Vector* mutable_velocity();
  inline ::mixr::recorder::pb::Vector* release_velocity();
  inline void set_allocated_velocity(::mixr::recorder::pb::Vector* velocity);

  // optional double avg_signal = 12;
  inline bool has_avg_signal() const;
  inline void clear_avg_signal();
  static const int kAvgSignalFieldNumber = 12;
  inline double avg_signal() const;
  inline void set_avg_signal(double value);

  // optional uint32 sl_index = 13;
  inline bool has_sl_index() const;
  inline void clear_sl_index();
  static const int kSlIndexFieldNumber = 13;
  inline ::google::protobuf::uint32 sl_index() const;
  inline void set_sl_index(::google::protobuf::uint32 value);

  // optional bool wpn_rel = 14;
  inline bool has_wpn_rel() const;
  inline void clear_wpn_rel();
  static const int kWpnRelFieldNumber = 14;
  inline bool wpn_rel() const;
  inline void set_wpn_rel(bool value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TrackData)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.TrackData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_true_az();
  inline void clear_has_true_az();
  inline void set_has_rel_az();
  inline void clear_has_rel_az();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_avg_signal();
  inline void clear_has_avg_signal();
  inline void set_has_sl_index();
  inline void clear_has_sl_index();
  inline void set_has_wpn_rel();
  inline void clear_has_wpn_rel();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double quality_;
  double true_az_;
  double rel_az_;
  double elevation_;
  double range_;
  double latitude_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 sl_index_;
  double longitude_;
  double altitude_;
  ::mixr::recorder::pb::Vector* position_;
  ::mixr::recorder::pb::Vector* velocity_;
  double avg_signal_;
  bool wpn_rel_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static TrackData* default_instance_;
};
// -------------------------------------------------------------------

class EmissionData : public ::google::protobuf::Message {
 public:
  EmissionData();
  virtual ~EmissionData();

  EmissionData(const EmissionData& from);

  inline EmissionData& operator=(const EmissionData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmissionData& default_instance();

  void Swap(EmissionData* other);

  // implements Message ----------------------------------------------

  EmissionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmissionData& from);
  void MergeFrom(const EmissionData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EmissionData_Polarization Polarization;
  static const Polarization NONE = EmissionData_Polarization_NONE;
  static const Polarization VERTICAL = EmissionData_Polarization_VERTICAL;
  static const Polarization HORIZONTAL = EmissionData_Polarization_HORIZONTAL;
  static const Polarization SLANT = EmissionData_Polarization_SLANT;
  static const Polarization RHC = EmissionData_Polarization_RHC;
  static const Polarization LHC = EmissionData_Polarization_LHC;
  static inline bool Polarization_IsValid(int value) {
    return EmissionData_Polarization_IsValid(value);
  }
  static const Polarization Polarization_MIN =
    EmissionData_Polarization_Polarization_MIN;
  static const Polarization Polarization_MAX =
    EmissionData_Polarization_Polarization_MAX;
  static const int Polarization_ARRAYSIZE =
    EmissionData_Polarization_Polarization_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Polarization_descriptor() {
    return EmissionData_Polarization_descriptor();
  }
  static inline const ::std::string& Polarization_Name(Polarization value) {
    return EmissionData_Polarization_Name(value);
  }
  static inline bool Polarization_Parse(const ::std::string& name,
      Polarization* value) {
    return EmissionData_Polarization_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double frequency = 1;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  inline double frequency() const;
  inline void set_frequency(double value);

  // optional double wave_length = 2;
  inline bool has_wave_length() const;
  inline void clear_wave_length();
  static const int kWaveLengthFieldNumber = 2;
  inline double wave_length() const;
  inline void set_wave_length(double value);

  // optional double pulse_width = 3;
  inline bool has_pulse_width() const;
  inline void clear_pulse_width();
  static const int kPulseWidthFieldNumber = 3;
  inline double pulse_width() const;
  inline void set_pulse_width(double value);

  // optional double bandwidth = 4;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 4;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);

  // optional double prf = 5;
  inline bool has_prf() const;
  inline void clear_prf();
  static const int kPrfFieldNumber = 5;
  inline double prf() const;
  inline void set_prf(double value);

  // optional double power = 6;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 6;
  inline double power() const;
  inline void set_power(double value);

  // optional .mixr.recorder.pb.EmissionData.Polarization polarization = 7;
  inline bool has_polarization() const;
  inline void clear_polarization();
  static const int kPolarizationFieldNumber = 7;
  inline ::mixr::recorder::pb::EmissionData_Polarization polarization() const;
  inline void set_polarization(::mixr::recorder::pb::EmissionData_Polarization value);

  // optional double azimuth_aoi = 8;
  inline bool has_azimuth_aoi() const;
  inline void clear_azimuth_aoi();
  static const int kAzimuthAoiFieldNumber = 8;
  inline double azimuth_aoi() const;
  inline void set_azimuth_aoi(double value);

  // optional double elevation_aoi = 9;
  inline bool has_elevation_aoi() const;
  inline void clear_elevation_aoi();
  static const int kElevationAoiFieldNumber = 9;
  inline double elevation_aoi() const;
  inline void set_elevation_aoi(double value);

  // optional .mixr.recorder.pb.PlayerId origin_id = 10;
  inline bool has_origin_id() const;
  inline void clear_origin_id();
  static const int kOriginIdFieldNumber = 10;
  inline const ::mixr::recorder::pb::PlayerId& origin_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_origin_id();
  inline ::mixr::recorder::pb::PlayerId* release_origin_id();
  inline void set_allocated_origin_id(::mixr::recorder::pb::PlayerId* origin_id);

  // optional .mixr.recorder.pb.PlayerId target_id = 11;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 11;
  inline const ::mixr::recorder::pb::PlayerId& target_id() const;
  inline ::mixr::recorder::pb::PlayerId* mutable_target_id();
  inline ::mixr::recorder::pb::PlayerId* release_target_id();
  inline void set_allocated_target_id(::mixr::recorder::pb::PlayerId* target_id);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(EmissionData)
  // @@protoc_insertion_point(class_scope:mixr.recorder.pb.EmissionData)
 private:
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_wave_length();
  inline void clear_has_wave_length();
  inline void set_has_pulse_width();
  inline void clear_has_pulse_width();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_prf();
  inline void clear_has_prf();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_polarization();
  inline void clear_has_polarization();
  inline void set_has_azimuth_aoi();
  inline void clear_has_azimuth_aoi();
  inline void set_has_elevation_aoi();
  inline void clear_has_elevation_aoi();
  inline void set_has_origin_id();
  inline void clear_has_origin_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double frequency_;
  double wave_length_;
  double pulse_width_;
  double bandwidth_;
  double prf_;
  double power_;
  double azimuth_aoi_;
  double elevation_aoi_;
  ::mixr::recorder::pb::PlayerId* origin_id_;
  ::mixr::recorder::pb::PlayerId* target_id_;
  int polarization_;
  friend void  protobuf_AddDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_AssignDesc_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();
  friend void protobuf_ShutdownFile_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto();

  void InitAsDefaultInstance();
  static EmissionData* default_instance_;
};
// ===================================================================


// ===================================================================

// DataRecord

// required .mixr.recorder.pb.Time time = 1;
inline bool DataRecord::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataRecord::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataRecord::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataRecord::clear_time() {
  if (time_ != NULL) time_->::mixr::recorder::pb::Time::Clear();
  clear_has_time();
}
inline const ::mixr::recorder::pb::Time& DataRecord::time() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.time)
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::mixr::recorder::pb::Time* DataRecord::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::mixr::recorder::pb::Time;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.time)
  return time_;
}
inline ::mixr::recorder::pb::Time* DataRecord::release_time() {
  clear_has_time();
  ::mixr::recorder::pb::Time* temp = time_;
  time_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_time(::mixr::recorder::pb::Time* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.time)
}

// required uint32 id = 2;
inline bool DataRecord::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataRecord::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataRecord::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataRecord::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 DataRecord::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.id)
  return id_;
}
inline void DataRecord::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.DataRecord.id)
}

// optional .mixr.recorder.pb.FileIdMsg file_id_msg = 11;
inline bool DataRecord::has_file_id_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataRecord::set_has_file_id_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataRecord::clear_has_file_id_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataRecord::clear_file_id_msg() {
  if (file_id_msg_ != NULL) file_id_msg_->::mixr::recorder::pb::FileIdMsg::Clear();
  clear_has_file_id_msg();
}
inline const ::mixr::recorder::pb::FileIdMsg& DataRecord::file_id_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.file_id_msg)
  return file_id_msg_ != NULL ? *file_id_msg_ : *default_instance_->file_id_msg_;
}
inline ::mixr::recorder::pb::FileIdMsg* DataRecord::mutable_file_id_msg() {
  set_has_file_id_msg();
  if (file_id_msg_ == NULL) file_id_msg_ = new ::mixr::recorder::pb::FileIdMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.file_id_msg)
  return file_id_msg_;
}
inline ::mixr::recorder::pb::FileIdMsg* DataRecord::release_file_id_msg() {
  clear_has_file_id_msg();
  ::mixr::recorder::pb::FileIdMsg* temp = file_id_msg_;
  file_id_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_file_id_msg(::mixr::recorder::pb::FileIdMsg* file_id_msg) {
  delete file_id_msg_;
  file_id_msg_ = file_id_msg;
  if (file_id_msg) {
    set_has_file_id_msg();
  } else {
    clear_has_file_id_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.file_id_msg)
}

// optional .mixr.recorder.pb.UnknownIdMsg unknown_id_msg = 13;
inline bool DataRecord::has_unknown_id_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataRecord::set_has_unknown_id_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataRecord::clear_has_unknown_id_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataRecord::clear_unknown_id_msg() {
  if (unknown_id_msg_ != NULL) unknown_id_msg_->::mixr::recorder::pb::UnknownIdMsg::Clear();
  clear_has_unknown_id_msg();
}
inline const ::mixr::recorder::pb::UnknownIdMsg& DataRecord::unknown_id_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.unknown_id_msg)
  return unknown_id_msg_ != NULL ? *unknown_id_msg_ : *default_instance_->unknown_id_msg_;
}
inline ::mixr::recorder::pb::UnknownIdMsg* DataRecord::mutable_unknown_id_msg() {
  set_has_unknown_id_msg();
  if (unknown_id_msg_ == NULL) unknown_id_msg_ = new ::mixr::recorder::pb::UnknownIdMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.unknown_id_msg)
  return unknown_id_msg_;
}
inline ::mixr::recorder::pb::UnknownIdMsg* DataRecord::release_unknown_id_msg() {
  clear_has_unknown_id_msg();
  ::mixr::recorder::pb::UnknownIdMsg* temp = unknown_id_msg_;
  unknown_id_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_unknown_id_msg(::mixr::recorder::pb::UnknownIdMsg* unknown_id_msg) {
  delete unknown_id_msg_;
  unknown_id_msg_ = unknown_id_msg;
  if (unknown_id_msg) {
    set_has_unknown_id_msg();
  } else {
    clear_has_unknown_id_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.unknown_id_msg)
}

// optional .mixr.recorder.pb.MarkerMsg marker_msg = 14;
inline bool DataRecord::has_marker_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataRecord::set_has_marker_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataRecord::clear_has_marker_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataRecord::clear_marker_msg() {
  if (marker_msg_ != NULL) marker_msg_->::mixr::recorder::pb::MarkerMsg::Clear();
  clear_has_marker_msg();
}
inline const ::mixr::recorder::pb::MarkerMsg& DataRecord::marker_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.marker_msg)
  return marker_msg_ != NULL ? *marker_msg_ : *default_instance_->marker_msg_;
}
inline ::mixr::recorder::pb::MarkerMsg* DataRecord::mutable_marker_msg() {
  set_has_marker_msg();
  if (marker_msg_ == NULL) marker_msg_ = new ::mixr::recorder::pb::MarkerMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.marker_msg)
  return marker_msg_;
}
inline ::mixr::recorder::pb::MarkerMsg* DataRecord::release_marker_msg() {
  clear_has_marker_msg();
  ::mixr::recorder::pb::MarkerMsg* temp = marker_msg_;
  marker_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_marker_msg(::mixr::recorder::pb::MarkerMsg* marker_msg) {
  delete marker_msg_;
  marker_msg_ = marker_msg;
  if (marker_msg) {
    set_has_marker_msg();
  } else {
    clear_has_marker_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.marker_msg)
}

// optional .mixr.recorder.pb.InputDeviceMsg input_device_msg = 15;
inline bool DataRecord::has_input_device_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataRecord::set_has_input_device_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataRecord::clear_has_input_device_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataRecord::clear_input_device_msg() {
  if (input_device_msg_ != NULL) input_device_msg_->::mixr::recorder::pb::InputDeviceMsg::Clear();
  clear_has_input_device_msg();
}
inline const ::mixr::recorder::pb::InputDeviceMsg& DataRecord::input_device_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.input_device_msg)
  return input_device_msg_ != NULL ? *input_device_msg_ : *default_instance_->input_device_msg_;
}
inline ::mixr::recorder::pb::InputDeviceMsg* DataRecord::mutable_input_device_msg() {
  set_has_input_device_msg();
  if (input_device_msg_ == NULL) input_device_msg_ = new ::mixr::recorder::pb::InputDeviceMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.input_device_msg)
  return input_device_msg_;
}
inline ::mixr::recorder::pb::InputDeviceMsg* DataRecord::release_input_device_msg() {
  clear_has_input_device_msg();
  ::mixr::recorder::pb::InputDeviceMsg* temp = input_device_msg_;
  input_device_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_input_device_msg(::mixr::recorder::pb::InputDeviceMsg* input_device_msg) {
  delete input_device_msg_;
  input_device_msg_ = input_device_msg;
  if (input_device_msg) {
    set_has_input_device_msg();
  } else {
    clear_has_input_device_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.input_device_msg)
}

// optional .mixr.recorder.pb.NewPlayerEventMsg new_player_event_msg = 31;
inline bool DataRecord::has_new_player_event_msg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataRecord::set_has_new_player_event_msg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataRecord::clear_has_new_player_event_msg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataRecord::clear_new_player_event_msg() {
  if (new_player_event_msg_ != NULL) new_player_event_msg_->::mixr::recorder::pb::NewPlayerEventMsg::Clear();
  clear_has_new_player_event_msg();
}
inline const ::mixr::recorder::pb::NewPlayerEventMsg& DataRecord::new_player_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.new_player_event_msg)
  return new_player_event_msg_ != NULL ? *new_player_event_msg_ : *default_instance_->new_player_event_msg_;
}
inline ::mixr::recorder::pb::NewPlayerEventMsg* DataRecord::mutable_new_player_event_msg() {
  set_has_new_player_event_msg();
  if (new_player_event_msg_ == NULL) new_player_event_msg_ = new ::mixr::recorder::pb::NewPlayerEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.new_player_event_msg)
  return new_player_event_msg_;
}
inline ::mixr::recorder::pb::NewPlayerEventMsg* DataRecord::release_new_player_event_msg() {
  clear_has_new_player_event_msg();
  ::mixr::recorder::pb::NewPlayerEventMsg* temp = new_player_event_msg_;
  new_player_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_new_player_event_msg(::mixr::recorder::pb::NewPlayerEventMsg* new_player_event_msg) {
  delete new_player_event_msg_;
  new_player_event_msg_ = new_player_event_msg;
  if (new_player_event_msg) {
    set_has_new_player_event_msg();
  } else {
    clear_has_new_player_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.new_player_event_msg)
}

// optional .mixr.recorder.pb.PlayerRemovedEventMsg player_removed_event_msg = 32;
inline bool DataRecord::has_player_removed_event_msg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataRecord::set_has_player_removed_event_msg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataRecord::clear_has_player_removed_event_msg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataRecord::clear_player_removed_event_msg() {
  if (player_removed_event_msg_ != NULL) player_removed_event_msg_->::mixr::recorder::pb::PlayerRemovedEventMsg::Clear();
  clear_has_player_removed_event_msg();
}
inline const ::mixr::recorder::pb::PlayerRemovedEventMsg& DataRecord::player_removed_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.player_removed_event_msg)
  return player_removed_event_msg_ != NULL ? *player_removed_event_msg_ : *default_instance_->player_removed_event_msg_;
}
inline ::mixr::recorder::pb::PlayerRemovedEventMsg* DataRecord::mutable_player_removed_event_msg() {
  set_has_player_removed_event_msg();
  if (player_removed_event_msg_ == NULL) player_removed_event_msg_ = new ::mixr::recorder::pb::PlayerRemovedEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.player_removed_event_msg)
  return player_removed_event_msg_;
}
inline ::mixr::recorder::pb::PlayerRemovedEventMsg* DataRecord::release_player_removed_event_msg() {
  clear_has_player_removed_event_msg();
  ::mixr::recorder::pb::PlayerRemovedEventMsg* temp = player_removed_event_msg_;
  player_removed_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_player_removed_event_msg(::mixr::recorder::pb::PlayerRemovedEventMsg* player_removed_event_msg) {
  delete player_removed_event_msg_;
  player_removed_event_msg_ = player_removed_event_msg;
  if (player_removed_event_msg) {
    set_has_player_removed_event_msg();
  } else {
    clear_has_player_removed_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.player_removed_event_msg)
}

// optional .mixr.recorder.pb.PlayerDataMsg player_data_msg = 33;
inline bool DataRecord::has_player_data_msg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataRecord::set_has_player_data_msg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataRecord::clear_has_player_data_msg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataRecord::clear_player_data_msg() {
  if (player_data_msg_ != NULL) player_data_msg_->::mixr::recorder::pb::PlayerDataMsg::Clear();
  clear_has_player_data_msg();
}
inline const ::mixr::recorder::pb::PlayerDataMsg& DataRecord::player_data_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.player_data_msg)
  return player_data_msg_ != NULL ? *player_data_msg_ : *default_instance_->player_data_msg_;
}
inline ::mixr::recorder::pb::PlayerDataMsg* DataRecord::mutable_player_data_msg() {
  set_has_player_data_msg();
  if (player_data_msg_ == NULL) player_data_msg_ = new ::mixr::recorder::pb::PlayerDataMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.player_data_msg)
  return player_data_msg_;
}
inline ::mixr::recorder::pb::PlayerDataMsg* DataRecord::release_player_data_msg() {
  clear_has_player_data_msg();
  ::mixr::recorder::pb::PlayerDataMsg* temp = player_data_msg_;
  player_data_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_player_data_msg(::mixr::recorder::pb::PlayerDataMsg* player_data_msg) {
  delete player_data_msg_;
  player_data_msg_ = player_data_msg;
  if (player_data_msg) {
    set_has_player_data_msg();
  } else {
    clear_has_player_data_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.player_data_msg)
}

// optional .mixr.recorder.pb.PlayerDamagedEventMsg player_damaged_event_msg = 34;
inline bool DataRecord::has_player_damaged_event_msg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataRecord::set_has_player_damaged_event_msg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataRecord::clear_has_player_damaged_event_msg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataRecord::clear_player_damaged_event_msg() {
  if (player_damaged_event_msg_ != NULL) player_damaged_event_msg_->::mixr::recorder::pb::PlayerDamagedEventMsg::Clear();
  clear_has_player_damaged_event_msg();
}
inline const ::mixr::recorder::pb::PlayerDamagedEventMsg& DataRecord::player_damaged_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.player_damaged_event_msg)
  return player_damaged_event_msg_ != NULL ? *player_damaged_event_msg_ : *default_instance_->player_damaged_event_msg_;
}
inline ::mixr::recorder::pb::PlayerDamagedEventMsg* DataRecord::mutable_player_damaged_event_msg() {
  set_has_player_damaged_event_msg();
  if (player_damaged_event_msg_ == NULL) player_damaged_event_msg_ = new ::mixr::recorder::pb::PlayerDamagedEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.player_damaged_event_msg)
  return player_damaged_event_msg_;
}
inline ::mixr::recorder::pb::PlayerDamagedEventMsg* DataRecord::release_player_damaged_event_msg() {
  clear_has_player_damaged_event_msg();
  ::mixr::recorder::pb::PlayerDamagedEventMsg* temp = player_damaged_event_msg_;
  player_damaged_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_player_damaged_event_msg(::mixr::recorder::pb::PlayerDamagedEventMsg* player_damaged_event_msg) {
  delete player_damaged_event_msg_;
  player_damaged_event_msg_ = player_damaged_event_msg;
  if (player_damaged_event_msg) {
    set_has_player_damaged_event_msg();
  } else {
    clear_has_player_damaged_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.player_damaged_event_msg)
}

// optional .mixr.recorder.pb.PlayerCollisionEventMsg player_collision_event_msg = 35;
inline bool DataRecord::has_player_collision_event_msg() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataRecord::set_has_player_collision_event_msg() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataRecord::clear_has_player_collision_event_msg() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataRecord::clear_player_collision_event_msg() {
  if (player_collision_event_msg_ != NULL) player_collision_event_msg_->::mixr::recorder::pb::PlayerCollisionEventMsg::Clear();
  clear_has_player_collision_event_msg();
}
inline const ::mixr::recorder::pb::PlayerCollisionEventMsg& DataRecord::player_collision_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.player_collision_event_msg)
  return player_collision_event_msg_ != NULL ? *player_collision_event_msg_ : *default_instance_->player_collision_event_msg_;
}
inline ::mixr::recorder::pb::PlayerCollisionEventMsg* DataRecord::mutable_player_collision_event_msg() {
  set_has_player_collision_event_msg();
  if (player_collision_event_msg_ == NULL) player_collision_event_msg_ = new ::mixr::recorder::pb::PlayerCollisionEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.player_collision_event_msg)
  return player_collision_event_msg_;
}
inline ::mixr::recorder::pb::PlayerCollisionEventMsg* DataRecord::release_player_collision_event_msg() {
  clear_has_player_collision_event_msg();
  ::mixr::recorder::pb::PlayerCollisionEventMsg* temp = player_collision_event_msg_;
  player_collision_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_player_collision_event_msg(::mixr::recorder::pb::PlayerCollisionEventMsg* player_collision_event_msg) {
  delete player_collision_event_msg_;
  player_collision_event_msg_ = player_collision_event_msg;
  if (player_collision_event_msg) {
    set_has_player_collision_event_msg();
  } else {
    clear_has_player_collision_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.player_collision_event_msg)
}

// optional .mixr.recorder.pb.PlayerCrashEventMsg player_crash_event_msg = 36;
inline bool DataRecord::has_player_crash_event_msg() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataRecord::set_has_player_crash_event_msg() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataRecord::clear_has_player_crash_event_msg() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataRecord::clear_player_crash_event_msg() {
  if (player_crash_event_msg_ != NULL) player_crash_event_msg_->::mixr::recorder::pb::PlayerCrashEventMsg::Clear();
  clear_has_player_crash_event_msg();
}
inline const ::mixr::recorder::pb::PlayerCrashEventMsg& DataRecord::player_crash_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.player_crash_event_msg)
  return player_crash_event_msg_ != NULL ? *player_crash_event_msg_ : *default_instance_->player_crash_event_msg_;
}
inline ::mixr::recorder::pb::PlayerCrashEventMsg* DataRecord::mutable_player_crash_event_msg() {
  set_has_player_crash_event_msg();
  if (player_crash_event_msg_ == NULL) player_crash_event_msg_ = new ::mixr::recorder::pb::PlayerCrashEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.player_crash_event_msg)
  return player_crash_event_msg_;
}
inline ::mixr::recorder::pb::PlayerCrashEventMsg* DataRecord::release_player_crash_event_msg() {
  clear_has_player_crash_event_msg();
  ::mixr::recorder::pb::PlayerCrashEventMsg* temp = player_crash_event_msg_;
  player_crash_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_player_crash_event_msg(::mixr::recorder::pb::PlayerCrashEventMsg* player_crash_event_msg) {
  delete player_crash_event_msg_;
  player_crash_event_msg_ = player_crash_event_msg;
  if (player_crash_event_msg) {
    set_has_player_crash_event_msg();
  } else {
    clear_has_player_crash_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.player_crash_event_msg)
}

// optional .mixr.recorder.pb.PlayerKilledEventMsg player_killed_event_msg = 37;
inline bool DataRecord::has_player_killed_event_msg() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DataRecord::set_has_player_killed_event_msg() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DataRecord::clear_has_player_killed_event_msg() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DataRecord::clear_player_killed_event_msg() {
  if (player_killed_event_msg_ != NULL) player_killed_event_msg_->::mixr::recorder::pb::PlayerKilledEventMsg::Clear();
  clear_has_player_killed_event_msg();
}
inline const ::mixr::recorder::pb::PlayerKilledEventMsg& DataRecord::player_killed_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.player_killed_event_msg)
  return player_killed_event_msg_ != NULL ? *player_killed_event_msg_ : *default_instance_->player_killed_event_msg_;
}
inline ::mixr::recorder::pb::PlayerKilledEventMsg* DataRecord::mutable_player_killed_event_msg() {
  set_has_player_killed_event_msg();
  if (player_killed_event_msg_ == NULL) player_killed_event_msg_ = new ::mixr::recorder::pb::PlayerKilledEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.player_killed_event_msg)
  return player_killed_event_msg_;
}
inline ::mixr::recorder::pb::PlayerKilledEventMsg* DataRecord::release_player_killed_event_msg() {
  clear_has_player_killed_event_msg();
  ::mixr::recorder::pb::PlayerKilledEventMsg* temp = player_killed_event_msg_;
  player_killed_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_player_killed_event_msg(::mixr::recorder::pb::PlayerKilledEventMsg* player_killed_event_msg) {
  delete player_killed_event_msg_;
  player_killed_event_msg_ = player_killed_event_msg;
  if (player_killed_event_msg) {
    set_has_player_killed_event_msg();
  } else {
    clear_has_player_killed_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.player_killed_event_msg)
}

// optional .mixr.recorder.pb.WeaponReleaseEventMsg weapon_release_event_msg = 51;
inline bool DataRecord::has_weapon_release_event_msg() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DataRecord::set_has_weapon_release_event_msg() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DataRecord::clear_has_weapon_release_event_msg() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DataRecord::clear_weapon_release_event_msg() {
  if (weapon_release_event_msg_ != NULL) weapon_release_event_msg_->::mixr::recorder::pb::WeaponReleaseEventMsg::Clear();
  clear_has_weapon_release_event_msg();
}
inline const ::mixr::recorder::pb::WeaponReleaseEventMsg& DataRecord::weapon_release_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.weapon_release_event_msg)
  return weapon_release_event_msg_ != NULL ? *weapon_release_event_msg_ : *default_instance_->weapon_release_event_msg_;
}
inline ::mixr::recorder::pb::WeaponReleaseEventMsg* DataRecord::mutable_weapon_release_event_msg() {
  set_has_weapon_release_event_msg();
  if (weapon_release_event_msg_ == NULL) weapon_release_event_msg_ = new ::mixr::recorder::pb::WeaponReleaseEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.weapon_release_event_msg)
  return weapon_release_event_msg_;
}
inline ::mixr::recorder::pb::WeaponReleaseEventMsg* DataRecord::release_weapon_release_event_msg() {
  clear_has_weapon_release_event_msg();
  ::mixr::recorder::pb::WeaponReleaseEventMsg* temp = weapon_release_event_msg_;
  weapon_release_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_weapon_release_event_msg(::mixr::recorder::pb::WeaponReleaseEventMsg* weapon_release_event_msg) {
  delete weapon_release_event_msg_;
  weapon_release_event_msg_ = weapon_release_event_msg;
  if (weapon_release_event_msg) {
    set_has_weapon_release_event_msg();
  } else {
    clear_has_weapon_release_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.weapon_release_event_msg)
}

// optional .mixr.recorder.pb.WeaponHungEventMsg weapon_hung_event_msg = 52;
inline bool DataRecord::has_weapon_hung_event_msg() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DataRecord::set_has_weapon_hung_event_msg() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DataRecord::clear_has_weapon_hung_event_msg() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DataRecord::clear_weapon_hung_event_msg() {
  if (weapon_hung_event_msg_ != NULL) weapon_hung_event_msg_->::mixr::recorder::pb::WeaponHungEventMsg::Clear();
  clear_has_weapon_hung_event_msg();
}
inline const ::mixr::recorder::pb::WeaponHungEventMsg& DataRecord::weapon_hung_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.weapon_hung_event_msg)
  return weapon_hung_event_msg_ != NULL ? *weapon_hung_event_msg_ : *default_instance_->weapon_hung_event_msg_;
}
inline ::mixr::recorder::pb::WeaponHungEventMsg* DataRecord::mutable_weapon_hung_event_msg() {
  set_has_weapon_hung_event_msg();
  if (weapon_hung_event_msg_ == NULL) weapon_hung_event_msg_ = new ::mixr::recorder::pb::WeaponHungEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.weapon_hung_event_msg)
  return weapon_hung_event_msg_;
}
inline ::mixr::recorder::pb::WeaponHungEventMsg* DataRecord::release_weapon_hung_event_msg() {
  clear_has_weapon_hung_event_msg();
  ::mixr::recorder::pb::WeaponHungEventMsg* temp = weapon_hung_event_msg_;
  weapon_hung_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_weapon_hung_event_msg(::mixr::recorder::pb::WeaponHungEventMsg* weapon_hung_event_msg) {
  delete weapon_hung_event_msg_;
  weapon_hung_event_msg_ = weapon_hung_event_msg;
  if (weapon_hung_event_msg) {
    set_has_weapon_hung_event_msg();
  } else {
    clear_has_weapon_hung_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.weapon_hung_event_msg)
}

// optional .mixr.recorder.pb.WeaponDetonationEventMsg weapon_detonation_event_msg = 53;
inline bool DataRecord::has_weapon_detonation_event_msg() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DataRecord::set_has_weapon_detonation_event_msg() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DataRecord::clear_has_weapon_detonation_event_msg() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DataRecord::clear_weapon_detonation_event_msg() {
  if (weapon_detonation_event_msg_ != NULL) weapon_detonation_event_msg_->::mixr::recorder::pb::WeaponDetonationEventMsg::Clear();
  clear_has_weapon_detonation_event_msg();
}
inline const ::mixr::recorder::pb::WeaponDetonationEventMsg& DataRecord::weapon_detonation_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.weapon_detonation_event_msg)
  return weapon_detonation_event_msg_ != NULL ? *weapon_detonation_event_msg_ : *default_instance_->weapon_detonation_event_msg_;
}
inline ::mixr::recorder::pb::WeaponDetonationEventMsg* DataRecord::mutable_weapon_detonation_event_msg() {
  set_has_weapon_detonation_event_msg();
  if (weapon_detonation_event_msg_ == NULL) weapon_detonation_event_msg_ = new ::mixr::recorder::pb::WeaponDetonationEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.weapon_detonation_event_msg)
  return weapon_detonation_event_msg_;
}
inline ::mixr::recorder::pb::WeaponDetonationEventMsg* DataRecord::release_weapon_detonation_event_msg() {
  clear_has_weapon_detonation_event_msg();
  ::mixr::recorder::pb::WeaponDetonationEventMsg* temp = weapon_detonation_event_msg_;
  weapon_detonation_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_weapon_detonation_event_msg(::mixr::recorder::pb::WeaponDetonationEventMsg* weapon_detonation_event_msg) {
  delete weapon_detonation_event_msg_;
  weapon_detonation_event_msg_ = weapon_detonation_event_msg;
  if (weapon_detonation_event_msg) {
    set_has_weapon_detonation_event_msg();
  } else {
    clear_has_weapon_detonation_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.weapon_detonation_event_msg)
}

// optional .mixr.recorder.pb.GunFiredEventMsg gun_fired_event_msg = 54;
inline bool DataRecord::has_gun_fired_event_msg() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DataRecord::set_has_gun_fired_event_msg() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DataRecord::clear_has_gun_fired_event_msg() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DataRecord::clear_gun_fired_event_msg() {
  if (gun_fired_event_msg_ != NULL) gun_fired_event_msg_->::mixr::recorder::pb::GunFiredEventMsg::Clear();
  clear_has_gun_fired_event_msg();
}
inline const ::mixr::recorder::pb::GunFiredEventMsg& DataRecord::gun_fired_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.gun_fired_event_msg)
  return gun_fired_event_msg_ != NULL ? *gun_fired_event_msg_ : *default_instance_->gun_fired_event_msg_;
}
inline ::mixr::recorder::pb::GunFiredEventMsg* DataRecord::mutable_gun_fired_event_msg() {
  set_has_gun_fired_event_msg();
  if (gun_fired_event_msg_ == NULL) gun_fired_event_msg_ = new ::mixr::recorder::pb::GunFiredEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.gun_fired_event_msg)
  return gun_fired_event_msg_;
}
inline ::mixr::recorder::pb::GunFiredEventMsg* DataRecord::release_gun_fired_event_msg() {
  clear_has_gun_fired_event_msg();
  ::mixr::recorder::pb::GunFiredEventMsg* temp = gun_fired_event_msg_;
  gun_fired_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_gun_fired_event_msg(::mixr::recorder::pb::GunFiredEventMsg* gun_fired_event_msg) {
  delete gun_fired_event_msg_;
  gun_fired_event_msg_ = gun_fired_event_msg;
  if (gun_fired_event_msg) {
    set_has_gun_fired_event_msg();
  } else {
    clear_has_gun_fired_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.gun_fired_event_msg)
}

// optional .mixr.recorder.pb.NewTrackEventMsg new_track_event_msg = 71;
inline bool DataRecord::has_new_track_event_msg() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DataRecord::set_has_new_track_event_msg() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DataRecord::clear_has_new_track_event_msg() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DataRecord::clear_new_track_event_msg() {
  if (new_track_event_msg_ != NULL) new_track_event_msg_->::mixr::recorder::pb::NewTrackEventMsg::Clear();
  clear_has_new_track_event_msg();
}
inline const ::mixr::recorder::pb::NewTrackEventMsg& DataRecord::new_track_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.new_track_event_msg)
  return new_track_event_msg_ != NULL ? *new_track_event_msg_ : *default_instance_->new_track_event_msg_;
}
inline ::mixr::recorder::pb::NewTrackEventMsg* DataRecord::mutable_new_track_event_msg() {
  set_has_new_track_event_msg();
  if (new_track_event_msg_ == NULL) new_track_event_msg_ = new ::mixr::recorder::pb::NewTrackEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.new_track_event_msg)
  return new_track_event_msg_;
}
inline ::mixr::recorder::pb::NewTrackEventMsg* DataRecord::release_new_track_event_msg() {
  clear_has_new_track_event_msg();
  ::mixr::recorder::pb::NewTrackEventMsg* temp = new_track_event_msg_;
  new_track_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_new_track_event_msg(::mixr::recorder::pb::NewTrackEventMsg* new_track_event_msg) {
  delete new_track_event_msg_;
  new_track_event_msg_ = new_track_event_msg;
  if (new_track_event_msg) {
    set_has_new_track_event_msg();
  } else {
    clear_has_new_track_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.new_track_event_msg)
}

// optional .mixr.recorder.pb.TrackRemovedEventMsg track_removed_event_msg = 72;
inline bool DataRecord::has_track_removed_event_msg() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DataRecord::set_has_track_removed_event_msg() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DataRecord::clear_has_track_removed_event_msg() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DataRecord::clear_track_removed_event_msg() {
  if (track_removed_event_msg_ != NULL) track_removed_event_msg_->::mixr::recorder::pb::TrackRemovedEventMsg::Clear();
  clear_has_track_removed_event_msg();
}
inline const ::mixr::recorder::pb::TrackRemovedEventMsg& DataRecord::track_removed_event_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.track_removed_event_msg)
  return track_removed_event_msg_ != NULL ? *track_removed_event_msg_ : *default_instance_->track_removed_event_msg_;
}
inline ::mixr::recorder::pb::TrackRemovedEventMsg* DataRecord::mutable_track_removed_event_msg() {
  set_has_track_removed_event_msg();
  if (track_removed_event_msg_ == NULL) track_removed_event_msg_ = new ::mixr::recorder::pb::TrackRemovedEventMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.track_removed_event_msg)
  return track_removed_event_msg_;
}
inline ::mixr::recorder::pb::TrackRemovedEventMsg* DataRecord::release_track_removed_event_msg() {
  clear_has_track_removed_event_msg();
  ::mixr::recorder::pb::TrackRemovedEventMsg* temp = track_removed_event_msg_;
  track_removed_event_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_track_removed_event_msg(::mixr::recorder::pb::TrackRemovedEventMsg* track_removed_event_msg) {
  delete track_removed_event_msg_;
  track_removed_event_msg_ = track_removed_event_msg;
  if (track_removed_event_msg) {
    set_has_track_removed_event_msg();
  } else {
    clear_has_track_removed_event_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.track_removed_event_msg)
}

// optional .mixr.recorder.pb.TrackDataMsg track_data_msg = 73;
inline bool DataRecord::has_track_data_msg() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DataRecord::set_has_track_data_msg() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DataRecord::clear_has_track_data_msg() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DataRecord::clear_track_data_msg() {
  if (track_data_msg_ != NULL) track_data_msg_->::mixr::recorder::pb::TrackDataMsg::Clear();
  clear_has_track_data_msg();
}
inline const ::mixr::recorder::pb::TrackDataMsg& DataRecord::track_data_msg() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.DataRecord.track_data_msg)
  return track_data_msg_ != NULL ? *track_data_msg_ : *default_instance_->track_data_msg_;
}
inline ::mixr::recorder::pb::TrackDataMsg* DataRecord::mutable_track_data_msg() {
  set_has_track_data_msg();
  if (track_data_msg_ == NULL) track_data_msg_ = new ::mixr::recorder::pb::TrackDataMsg;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.DataRecord.track_data_msg)
  return track_data_msg_;
}
inline ::mixr::recorder::pb::TrackDataMsg* DataRecord::release_track_data_msg() {
  clear_has_track_data_msg();
  ::mixr::recorder::pb::TrackDataMsg* temp = track_data_msg_;
  track_data_msg_ = NULL;
  return temp;
}
inline void DataRecord::set_allocated_track_data_msg(::mixr::recorder::pb::TrackDataMsg* track_data_msg) {
  delete track_data_msg_;
  track_data_msg_ = track_data_msg;
  if (track_data_msg) {
    set_has_track_data_msg();
  } else {
    clear_has_track_data_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.DataRecord.track_data_msg)
}

// -------------------------------------------------------------------

// FileIdMsg

// optional string event_name = 1;
inline bool FileIdMsg::has_event_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileIdMsg::set_has_event_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileIdMsg::clear_has_event_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileIdMsg::clear_event_name() {
  if (event_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    event_name_->clear();
  }
  clear_has_event_name();
}
inline const ::std::string& FileIdMsg::event_name() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.FileIdMsg.event_name)
  return *event_name_;
}
inline void FileIdMsg::set_event_name(const ::std::string& value) {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    event_name_ = new ::std::string;
  }
  event_name_->assign(value);
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.FileIdMsg.event_name)
}
inline void FileIdMsg::set_event_name(const char* value) {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    event_name_ = new ::std::string;
  }
  event_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mixr.recorder.pb.FileIdMsg.event_name)
}
inline void FileIdMsg::set_event_name(const char* value, size_t size) {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    event_name_ = new ::std::string;
  }
  event_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mixr.recorder.pb.FileIdMsg.event_name)
}
inline ::std::string* FileIdMsg::mutable_event_name() {
  set_has_event_name();
  if (event_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    event_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.FileIdMsg.event_name)
  return event_name_;
}
inline ::std::string* FileIdMsg::release_event_name() {
  clear_has_event_name();
  if (event_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = event_name_;
    event_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FileIdMsg::set_allocated_event_name(::std::string* event_name) {
  if (event_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete event_name_;
  }
  if (event_name) {
    set_has_event_name();
    event_name_ = event_name;
  } else {
    clear_has_event_name();
    event_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.FileIdMsg.event_name)
}

// optional string application = 2;
inline bool FileIdMsg::has_application() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileIdMsg::set_has_application() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileIdMsg::clear_has_application() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileIdMsg::clear_application() {
  if (application_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    application_->clear();
  }
  clear_has_application();
}
inline const ::std::string& FileIdMsg::application() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.FileIdMsg.application)
  return *application_;
}
inline void FileIdMsg::set_application(const ::std::string& value) {
  set_has_application();
  if (application_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    application_ = new ::std::string;
  }
  application_->assign(value);
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.FileIdMsg.application)
}
inline void FileIdMsg::set_application(const char* value) {
  set_has_application();
  if (application_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    application_ = new ::std::string;
  }
  application_->assign(value);
  // @@protoc_insertion_point(field_set_char:mixr.recorder.pb.FileIdMsg.application)
}
inline void FileIdMsg::set_application(const char* value, size_t size) {
  set_has_application();
  if (application_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    application_ = new ::std::string;
  }
  application_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mixr.recorder.pb.FileIdMsg.application)
}
inline ::std::string* FileIdMsg::mutable_application() {
  set_has_application();
  if (application_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    application_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.FileIdMsg.application)
  return application_;
}
inline ::std::string* FileIdMsg::release_application() {
  clear_has_application();
  if (application_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = application_;
    application_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FileIdMsg::set_allocated_application(::std::string* application) {
  if (application_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete application_;
  }
  if (application) {
    set_has_application();
    application_ = application;
  } else {
    clear_has_application();
    application_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.FileIdMsg.application)
}

// optional uint32 case_num = 3;
inline bool FileIdMsg::has_case_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileIdMsg::set_has_case_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileIdMsg::clear_has_case_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileIdMsg::clear_case_num() {
  case_num_ = 0u;
  clear_has_case_num();
}
inline ::google::protobuf::uint32 FileIdMsg::case_num() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.FileIdMsg.case_num)
  return case_num_;
}
inline void FileIdMsg::set_case_num(::google::protobuf::uint32 value) {
  set_has_case_num();
  case_num_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.FileIdMsg.case_num)
}

// optional uint32 mission_num = 4;
inline bool FileIdMsg::has_mission_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileIdMsg::set_has_mission_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileIdMsg::clear_has_mission_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileIdMsg::clear_mission_num() {
  mission_num_ = 0u;
  clear_has_mission_num();
}
inline ::google::protobuf::uint32 FileIdMsg::mission_num() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.FileIdMsg.mission_num)
  return mission_num_;
}
inline void FileIdMsg::set_mission_num(::google::protobuf::uint32 value) {
  set_has_mission_num();
  mission_num_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.FileIdMsg.mission_num)
}

// optional uint32 subject_num = 5;
inline bool FileIdMsg::has_subject_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileIdMsg::set_has_subject_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileIdMsg::clear_has_subject_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileIdMsg::clear_subject_num() {
  subject_num_ = 0u;
  clear_has_subject_num();
}
inline ::google::protobuf::uint32 FileIdMsg::subject_num() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.FileIdMsg.subject_num)
  return subject_num_;
}
inline void FileIdMsg::set_subject_num(::google::protobuf::uint32 value) {
  set_has_subject_num();
  subject_num_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.FileIdMsg.subject_num)
}

// optional uint32 run_num = 6;
inline bool FileIdMsg::has_run_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileIdMsg::set_has_run_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileIdMsg::clear_has_run_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileIdMsg::clear_run_num() {
  run_num_ = 0u;
  clear_has_run_num();
}
inline ::google::protobuf::uint32 FileIdMsg::run_num() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.FileIdMsg.run_num)
  return run_num_;
}
inline void FileIdMsg::set_run_num(::google::protobuf::uint32 value) {
  set_has_run_num();
  run_num_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.FileIdMsg.run_num)
}

// optional uint32 day = 7;
inline bool FileIdMsg::has_day() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FileIdMsg::set_has_day() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FileIdMsg::clear_has_day() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FileIdMsg::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 FileIdMsg::day() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.FileIdMsg.day)
  return day_;
}
inline void FileIdMsg::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.FileIdMsg.day)
}

// optional uint32 month = 8;
inline bool FileIdMsg::has_month() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FileIdMsg::set_has_month() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FileIdMsg::clear_has_month() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FileIdMsg::clear_month() {
  month_ = 0u;
  clear_has_month();
}
inline ::google::protobuf::uint32 FileIdMsg::month() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.FileIdMsg.month)
  return month_;
}
inline void FileIdMsg::set_month(::google::protobuf::uint32 value) {
  set_has_month();
  month_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.FileIdMsg.month)
}

// optional uint32 year = 9;
inline bool FileIdMsg::has_year() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FileIdMsg::set_has_year() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FileIdMsg::clear_has_year() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FileIdMsg::clear_year() {
  year_ = 0u;
  clear_has_year();
}
inline ::google::protobuf::uint32 FileIdMsg::year() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.FileIdMsg.year)
  return year_;
}
inline void FileIdMsg::set_year(::google::protobuf::uint32 value) {
  set_has_year();
  year_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.FileIdMsg.year)
}

// -------------------------------------------------------------------

// UnknownIdMsg

// required uint32 id = 1;
inline bool UnknownIdMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnknownIdMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnknownIdMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnknownIdMsg::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 UnknownIdMsg::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.UnknownIdMsg.id)
  return id_;
}
inline void UnknownIdMsg::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.UnknownIdMsg.id)
}

// -------------------------------------------------------------------

// MarkerMsg

// optional uint32 id = 1;
inline bool MarkerMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarkerMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarkerMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarkerMsg::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MarkerMsg::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.MarkerMsg.id)
  return id_;
}
inline void MarkerMsg::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.MarkerMsg.id)
}

// optional uint32 source_id = 2;
inline bool MarkerMsg::has_source_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarkerMsg::set_has_source_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarkerMsg::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarkerMsg::clear_source_id() {
  source_id_ = 0u;
  clear_has_source_id();
}
inline ::google::protobuf::uint32 MarkerMsg::source_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.MarkerMsg.source_id)
  return source_id_;
}
inline void MarkerMsg::set_source_id(::google::protobuf::uint32 value) {
  set_has_source_id();
  source_id_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.MarkerMsg.source_id)
}

// -------------------------------------------------------------------

// InputDeviceMsg

// required uint32 id = 1;
inline bool InputDeviceMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputDeviceMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputDeviceMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputDeviceMsg::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 InputDeviceMsg::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.InputDeviceMsg.id)
  return id_;
}
inline void InputDeviceMsg::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.InputDeviceMsg.id)
}

// optional uint32 source_id = 2;
inline bool InputDeviceMsg::has_source_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputDeviceMsg::set_has_source_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputDeviceMsg::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputDeviceMsg::clear_source_id() {
  source_id_ = 0u;
  clear_has_source_id();
}
inline ::google::protobuf::uint32 InputDeviceMsg::source_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.InputDeviceMsg.source_id)
  return source_id_;
}
inline void InputDeviceMsg::set_source_id(::google::protobuf::uint32 value) {
  set_has_source_id();
  source_id_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.InputDeviceMsg.source_id)
}

// optional float value = 3;
inline bool InputDeviceMsg::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputDeviceMsg::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputDeviceMsg::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputDeviceMsg::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float InputDeviceMsg::value() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.InputDeviceMsg.value)
  return value_;
}
inline void InputDeviceMsg::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.InputDeviceMsg.value)
}

// -------------------------------------------------------------------

// NewPlayerEventMsg

// required .mixr.recorder.pb.PlayerId id = 1;
inline bool NewPlayerEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewPlayerEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewPlayerEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewPlayerEventMsg::clear_id() {
  if (id_ != NULL) id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::mixr::recorder::pb::PlayerId& NewPlayerEventMsg::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.NewPlayerEventMsg.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mixr::recorder::pb::PlayerId* NewPlayerEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.NewPlayerEventMsg.id)
  return id_;
}
inline ::mixr::recorder::pb::PlayerId* NewPlayerEventMsg::release_id() {
  clear_has_id();
  ::mixr::recorder::pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}
inline void NewPlayerEventMsg::set_allocated_id(::mixr::recorder::pb::PlayerId* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.NewPlayerEventMsg.id)
}

// required .mixr.recorder.pb.PlayerState state = 2;
inline bool NewPlayerEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewPlayerEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewPlayerEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewPlayerEventMsg::clear_state() {
  if (state_ != NULL) state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::mixr::recorder::pb::PlayerState& NewPlayerEventMsg::state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.NewPlayerEventMsg.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::mixr::recorder::pb::PlayerState* NewPlayerEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.NewPlayerEventMsg.state)
  return state_;
}
inline ::mixr::recorder::pb::PlayerState* NewPlayerEventMsg::release_state() {
  clear_has_state();
  ::mixr::recorder::pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void NewPlayerEventMsg::set_allocated_state(::mixr::recorder::pb::PlayerState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.NewPlayerEventMsg.state)
}

// -------------------------------------------------------------------

// PlayerRemovedEventMsg

// required .mixr.recorder.pb.PlayerId id = 1;
inline bool PlayerRemovedEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerRemovedEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerRemovedEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerRemovedEventMsg::clear_id() {
  if (id_ != NULL) id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::mixr::recorder::pb::PlayerId& PlayerRemovedEventMsg::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerRemovedEventMsg.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerRemovedEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerRemovedEventMsg.id)
  return id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerRemovedEventMsg::release_id() {
  clear_has_id();
  ::mixr::recorder::pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}
inline void PlayerRemovedEventMsg::set_allocated_id(::mixr::recorder::pb::PlayerId* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerRemovedEventMsg.id)
}

// optional .mixr.recorder.pb.PlayerState state = 2;
inline bool PlayerRemovedEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerRemovedEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerRemovedEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerRemovedEventMsg::clear_state() {
  if (state_ != NULL) state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::mixr::recorder::pb::PlayerState& PlayerRemovedEventMsg::state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerRemovedEventMsg.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerRemovedEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerRemovedEventMsg.state)
  return state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerRemovedEventMsg::release_state() {
  clear_has_state();
  ::mixr::recorder::pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void PlayerRemovedEventMsg::set_allocated_state(::mixr::recorder::pb::PlayerState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerRemovedEventMsg.state)
}

// -------------------------------------------------------------------

// PlayerDataMsg

// required .mixr.recorder.pb.PlayerId id = 1;
inline bool PlayerDataMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerDataMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerDataMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerDataMsg::clear_id() {
  if (id_ != NULL) id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::mixr::recorder::pb::PlayerId& PlayerDataMsg::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerDataMsg.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerDataMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerDataMsg.id)
  return id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerDataMsg::release_id() {
  clear_has_id();
  ::mixr::recorder::pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}
inline void PlayerDataMsg::set_allocated_id(::mixr::recorder::pb::PlayerId* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerDataMsg.id)
}

// required .mixr.recorder.pb.PlayerState state = 2;
inline bool PlayerDataMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerDataMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerDataMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerDataMsg::clear_state() {
  if (state_ != NULL) state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::mixr::recorder::pb::PlayerState& PlayerDataMsg::state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerDataMsg.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerDataMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerDataMsg.state)
  return state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerDataMsg::release_state() {
  clear_has_state();
  ::mixr::recorder::pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void PlayerDataMsg::set_allocated_state(::mixr::recorder::pb::PlayerState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerDataMsg.state)
}

// optional double alpha = 3;
inline bool PlayerDataMsg::has_alpha() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerDataMsg::set_has_alpha() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerDataMsg::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerDataMsg::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline double PlayerDataMsg::alpha() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerDataMsg.alpha)
  return alpha_;
}
inline void PlayerDataMsg::set_alpha(double value) {
  set_has_alpha();
  alpha_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.PlayerDataMsg.alpha)
}

// optional double beta = 4;
inline bool PlayerDataMsg::has_beta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerDataMsg::set_has_beta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerDataMsg::clear_has_beta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerDataMsg::clear_beta() {
  beta_ = 0;
  clear_has_beta();
}
inline double PlayerDataMsg::beta() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerDataMsg.beta)
  return beta_;
}
inline void PlayerDataMsg::set_beta(double value) {
  set_has_beta();
  beta_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.PlayerDataMsg.beta)
}

// optional double cas = 5;
inline bool PlayerDataMsg::has_cas() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerDataMsg::set_has_cas() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerDataMsg::clear_has_cas() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerDataMsg::clear_cas() {
  cas_ = 0;
  clear_has_cas();
}
inline double PlayerDataMsg::cas() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerDataMsg.cas)
  return cas_;
}
inline void PlayerDataMsg::set_cas(double value) {
  set_has_cas();
  cas_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.PlayerDataMsg.cas)
}

// -------------------------------------------------------------------

// PlayerDamagedEventMsg

// required .mixr.recorder.pb.PlayerId id = 1;
inline bool PlayerDamagedEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerDamagedEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerDamagedEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerDamagedEventMsg::clear_id() {
  if (id_ != NULL) id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::mixr::recorder::pb::PlayerId& PlayerDamagedEventMsg::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerDamagedEventMsg.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerDamagedEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerDamagedEventMsg.id)
  return id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerDamagedEventMsg::release_id() {
  clear_has_id();
  ::mixr::recorder::pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}
inline void PlayerDamagedEventMsg::set_allocated_id(::mixr::recorder::pb::PlayerId* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerDamagedEventMsg.id)
}

// optional .mixr.recorder.pb.PlayerState state = 2;
inline bool PlayerDamagedEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerDamagedEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerDamagedEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerDamagedEventMsg::clear_state() {
  if (state_ != NULL) state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::mixr::recorder::pb::PlayerState& PlayerDamagedEventMsg::state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerDamagedEventMsg.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerDamagedEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerDamagedEventMsg.state)
  return state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerDamagedEventMsg::release_state() {
  clear_has_state();
  ::mixr::recorder::pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void PlayerDamagedEventMsg::set_allocated_state(::mixr::recorder::pb::PlayerState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerDamagedEventMsg.state)
}

// -------------------------------------------------------------------

// PlayerCollisionEventMsg

// required .mixr.recorder.pb.PlayerId id = 1;
inline bool PlayerCollisionEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCollisionEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCollisionEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCollisionEventMsg::clear_id() {
  if (id_ != NULL) id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::mixr::recorder::pb::PlayerId& PlayerCollisionEventMsg::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerCollisionEventMsg.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerCollisionEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerCollisionEventMsg.id)
  return id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerCollisionEventMsg::release_id() {
  clear_has_id();
  ::mixr::recorder::pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}
inline void PlayerCollisionEventMsg::set_allocated_id(::mixr::recorder::pb::PlayerId* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerCollisionEventMsg.id)
}

// optional .mixr.recorder.pb.PlayerState state = 2;
inline bool PlayerCollisionEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCollisionEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCollisionEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCollisionEventMsg::clear_state() {
  if (state_ != NULL) state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::mixr::recorder::pb::PlayerState& PlayerCollisionEventMsg::state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerCollisionEventMsg.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerCollisionEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerCollisionEventMsg.state)
  return state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerCollisionEventMsg::release_state() {
  clear_has_state();
  ::mixr::recorder::pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void PlayerCollisionEventMsg::set_allocated_state(::mixr::recorder::pb::PlayerState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerCollisionEventMsg.state)
}

// optional .mixr.recorder.pb.PlayerId other_player_id = 3;
inline bool PlayerCollisionEventMsg::has_other_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerCollisionEventMsg::set_has_other_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerCollisionEventMsg::clear_has_other_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerCollisionEventMsg::clear_other_player_id() {
  if (other_player_id_ != NULL) other_player_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_other_player_id();
}
inline const ::mixr::recorder::pb::PlayerId& PlayerCollisionEventMsg::other_player_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerCollisionEventMsg.other_player_id)
  return other_player_id_ != NULL ? *other_player_id_ : *default_instance_->other_player_id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerCollisionEventMsg::mutable_other_player_id() {
  set_has_other_player_id();
  if (other_player_id_ == NULL) other_player_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerCollisionEventMsg.other_player_id)
  return other_player_id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerCollisionEventMsg::release_other_player_id() {
  clear_has_other_player_id();
  ::mixr::recorder::pb::PlayerId* temp = other_player_id_;
  other_player_id_ = NULL;
  return temp;
}
inline void PlayerCollisionEventMsg::set_allocated_other_player_id(::mixr::recorder::pb::PlayerId* other_player_id) {
  delete other_player_id_;
  other_player_id_ = other_player_id;
  if (other_player_id) {
    set_has_other_player_id();
  } else {
    clear_has_other_player_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerCollisionEventMsg.other_player_id)
}

// -------------------------------------------------------------------

// PlayerCrashEventMsg

// required .mixr.recorder.pb.PlayerId id = 1;
inline bool PlayerCrashEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCrashEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCrashEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCrashEventMsg::clear_id() {
  if (id_ != NULL) id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::mixr::recorder::pb::PlayerId& PlayerCrashEventMsg::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerCrashEventMsg.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerCrashEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerCrashEventMsg.id)
  return id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerCrashEventMsg::release_id() {
  clear_has_id();
  ::mixr::recorder::pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}
inline void PlayerCrashEventMsg::set_allocated_id(::mixr::recorder::pb::PlayerId* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerCrashEventMsg.id)
}

// optional .mixr.recorder.pb.PlayerState state = 2;
inline bool PlayerCrashEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCrashEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCrashEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCrashEventMsg::clear_state() {
  if (state_ != NULL) state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::mixr::recorder::pb::PlayerState& PlayerCrashEventMsg::state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerCrashEventMsg.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerCrashEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerCrashEventMsg.state)
  return state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerCrashEventMsg::release_state() {
  clear_has_state();
  ::mixr::recorder::pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void PlayerCrashEventMsg::set_allocated_state(::mixr::recorder::pb::PlayerState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerCrashEventMsg.state)
}

// -------------------------------------------------------------------

// PlayerKilledEventMsg

// required .mixr.recorder.pb.PlayerId id = 1;
inline bool PlayerKilledEventMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerKilledEventMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerKilledEventMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerKilledEventMsg::clear_id() {
  if (id_ != NULL) id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_id();
}
inline const ::mixr::recorder::pb::PlayerId& PlayerKilledEventMsg::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerKilledEventMsg.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerKilledEventMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerKilledEventMsg.id)
  return id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerKilledEventMsg::release_id() {
  clear_has_id();
  ::mixr::recorder::pb::PlayerId* temp = id_;
  id_ = NULL;
  return temp;
}
inline void PlayerKilledEventMsg::set_allocated_id(::mixr::recorder::pb::PlayerId* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerKilledEventMsg.id)
}

// optional .mixr.recorder.pb.PlayerState state = 2;
inline bool PlayerKilledEventMsg::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerKilledEventMsg::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerKilledEventMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerKilledEventMsg::clear_state() {
  if (state_ != NULL) state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_state();
}
inline const ::mixr::recorder::pb::PlayerState& PlayerKilledEventMsg::state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerKilledEventMsg.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerKilledEventMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerKilledEventMsg.state)
  return state_;
}
inline ::mixr::recorder::pb::PlayerState* PlayerKilledEventMsg::release_state() {
  clear_has_state();
  ::mixr::recorder::pb::PlayerState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void PlayerKilledEventMsg::set_allocated_state(::mixr::recorder::pb::PlayerState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerKilledEventMsg.state)
}

// optional .mixr.recorder.pb.PlayerId shooter_id = 3;
inline bool PlayerKilledEventMsg::has_shooter_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerKilledEventMsg::set_has_shooter_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerKilledEventMsg::clear_has_shooter_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerKilledEventMsg::clear_shooter_id() {
  if (shooter_id_ != NULL) shooter_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_shooter_id();
}
inline const ::mixr::recorder::pb::PlayerId& PlayerKilledEventMsg::shooter_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerKilledEventMsg.shooter_id)
  return shooter_id_ != NULL ? *shooter_id_ : *default_instance_->shooter_id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerKilledEventMsg::mutable_shooter_id() {
  set_has_shooter_id();
  if (shooter_id_ == NULL) shooter_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerKilledEventMsg.shooter_id)
  return shooter_id_;
}
inline ::mixr::recorder::pb::PlayerId* PlayerKilledEventMsg::release_shooter_id() {
  clear_has_shooter_id();
  ::mixr::recorder::pb::PlayerId* temp = shooter_id_;
  shooter_id_ = NULL;
  return temp;
}
inline void PlayerKilledEventMsg::set_allocated_shooter_id(::mixr::recorder::pb::PlayerId* shooter_id) {
  delete shooter_id_;
  shooter_id_ = shooter_id;
  if (shooter_id) {
    set_has_shooter_id();
  } else {
    clear_has_shooter_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerKilledEventMsg.shooter_id)
}

// -------------------------------------------------------------------

// WeaponReleaseEventMsg

// required .mixr.recorder.pb.PlayerId wpn_id = 1;
inline bool WeaponReleaseEventMsg::has_wpn_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponReleaseEventMsg::set_has_wpn_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponReleaseEventMsg::clear_has_wpn_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponReleaseEventMsg::clear_wpn_id() {
  if (wpn_id_ != NULL) wpn_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_wpn_id();
}
inline const ::mixr::recorder::pb::PlayerId& WeaponReleaseEventMsg::wpn_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponReleaseEventMsg.wpn_id)
  return wpn_id_ != NULL ? *wpn_id_ : *default_instance_->wpn_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponReleaseEventMsg::mutable_wpn_id() {
  set_has_wpn_id();
  if (wpn_id_ == NULL) wpn_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponReleaseEventMsg.wpn_id)
  return wpn_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponReleaseEventMsg::release_wpn_id() {
  clear_has_wpn_id();
  ::mixr::recorder::pb::PlayerId* temp = wpn_id_;
  wpn_id_ = NULL;
  return temp;
}
inline void WeaponReleaseEventMsg::set_allocated_wpn_id(::mixr::recorder::pb::PlayerId* wpn_id) {
  delete wpn_id_;
  wpn_id_ = wpn_id;
  if (wpn_id) {
    set_has_wpn_id();
  } else {
    clear_has_wpn_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponReleaseEventMsg.wpn_id)
}

// optional .mixr.recorder.pb.PlayerState wpn_state = 2;
inline bool WeaponReleaseEventMsg::has_wpn_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponReleaseEventMsg::set_has_wpn_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponReleaseEventMsg::clear_has_wpn_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponReleaseEventMsg::clear_wpn_state() {
  if (wpn_state_ != NULL) wpn_state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_wpn_state();
}
inline const ::mixr::recorder::pb::PlayerState& WeaponReleaseEventMsg::wpn_state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponReleaseEventMsg.wpn_state)
  return wpn_state_ != NULL ? *wpn_state_ : *default_instance_->wpn_state_;
}
inline ::mixr::recorder::pb::PlayerState* WeaponReleaseEventMsg::mutable_wpn_state() {
  set_has_wpn_state();
  if (wpn_state_ == NULL) wpn_state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponReleaseEventMsg.wpn_state)
  return wpn_state_;
}
inline ::mixr::recorder::pb::PlayerState* WeaponReleaseEventMsg::release_wpn_state() {
  clear_has_wpn_state();
  ::mixr::recorder::pb::PlayerState* temp = wpn_state_;
  wpn_state_ = NULL;
  return temp;
}
inline void WeaponReleaseEventMsg::set_allocated_wpn_state(::mixr::recorder::pb::PlayerState* wpn_state) {
  delete wpn_state_;
  wpn_state_ = wpn_state;
  if (wpn_state) {
    set_has_wpn_state();
  } else {
    clear_has_wpn_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponReleaseEventMsg.wpn_state)
}

// optional .mixr.recorder.pb.PlayerId shooter_id = 3;
inline bool WeaponReleaseEventMsg::has_shooter_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponReleaseEventMsg::set_has_shooter_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponReleaseEventMsg::clear_has_shooter_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponReleaseEventMsg::clear_shooter_id() {
  if (shooter_id_ != NULL) shooter_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_shooter_id();
}
inline const ::mixr::recorder::pb::PlayerId& WeaponReleaseEventMsg::shooter_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponReleaseEventMsg.shooter_id)
  return shooter_id_ != NULL ? *shooter_id_ : *default_instance_->shooter_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponReleaseEventMsg::mutable_shooter_id() {
  set_has_shooter_id();
  if (shooter_id_ == NULL) shooter_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponReleaseEventMsg.shooter_id)
  return shooter_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponReleaseEventMsg::release_shooter_id() {
  clear_has_shooter_id();
  ::mixr::recorder::pb::PlayerId* temp = shooter_id_;
  shooter_id_ = NULL;
  return temp;
}
inline void WeaponReleaseEventMsg::set_allocated_shooter_id(::mixr::recorder::pb::PlayerId* shooter_id) {
  delete shooter_id_;
  shooter_id_ = shooter_id;
  if (shooter_id) {
    set_has_shooter_id();
  } else {
    clear_has_shooter_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponReleaseEventMsg.shooter_id)
}

// optional .mixr.recorder.pb.PlayerId tgt_id = 4;
inline bool WeaponReleaseEventMsg::has_tgt_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeaponReleaseEventMsg::set_has_tgt_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeaponReleaseEventMsg::clear_has_tgt_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeaponReleaseEventMsg::clear_tgt_id() {
  if (tgt_id_ != NULL) tgt_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_tgt_id();
}
inline const ::mixr::recorder::pb::PlayerId& WeaponReleaseEventMsg::tgt_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponReleaseEventMsg.tgt_id)
  return tgt_id_ != NULL ? *tgt_id_ : *default_instance_->tgt_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponReleaseEventMsg::mutable_tgt_id() {
  set_has_tgt_id();
  if (tgt_id_ == NULL) tgt_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponReleaseEventMsg.tgt_id)
  return tgt_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponReleaseEventMsg::release_tgt_id() {
  clear_has_tgt_id();
  ::mixr::recorder::pb::PlayerId* temp = tgt_id_;
  tgt_id_ = NULL;
  return temp;
}
inline void WeaponReleaseEventMsg::set_allocated_tgt_id(::mixr::recorder::pb::PlayerId* tgt_id) {
  delete tgt_id_;
  tgt_id_ = tgt_id;
  if (tgt_id) {
    set_has_tgt_id();
  } else {
    clear_has_tgt_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponReleaseEventMsg.tgt_id)
}

// -------------------------------------------------------------------

// WeaponHungEventMsg

// required .mixr.recorder.pb.PlayerId wpn_id = 1;
inline bool WeaponHungEventMsg::has_wpn_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponHungEventMsg::set_has_wpn_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponHungEventMsg::clear_has_wpn_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponHungEventMsg::clear_wpn_id() {
  if (wpn_id_ != NULL) wpn_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_wpn_id();
}
inline const ::mixr::recorder::pb::PlayerId& WeaponHungEventMsg::wpn_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponHungEventMsg.wpn_id)
  return wpn_id_ != NULL ? *wpn_id_ : *default_instance_->wpn_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponHungEventMsg::mutable_wpn_id() {
  set_has_wpn_id();
  if (wpn_id_ == NULL) wpn_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponHungEventMsg.wpn_id)
  return wpn_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponHungEventMsg::release_wpn_id() {
  clear_has_wpn_id();
  ::mixr::recorder::pb::PlayerId* temp = wpn_id_;
  wpn_id_ = NULL;
  return temp;
}
inline void WeaponHungEventMsg::set_allocated_wpn_id(::mixr::recorder::pb::PlayerId* wpn_id) {
  delete wpn_id_;
  wpn_id_ = wpn_id;
  if (wpn_id) {
    set_has_wpn_id();
  } else {
    clear_has_wpn_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponHungEventMsg.wpn_id)
}

// optional .mixr.recorder.pb.PlayerState wpn_state = 2;
inline bool WeaponHungEventMsg::has_wpn_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponHungEventMsg::set_has_wpn_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponHungEventMsg::clear_has_wpn_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponHungEventMsg::clear_wpn_state() {
  if (wpn_state_ != NULL) wpn_state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_wpn_state();
}
inline const ::mixr::recorder::pb::PlayerState& WeaponHungEventMsg::wpn_state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponHungEventMsg.wpn_state)
  return wpn_state_ != NULL ? *wpn_state_ : *default_instance_->wpn_state_;
}
inline ::mixr::recorder::pb::PlayerState* WeaponHungEventMsg::mutable_wpn_state() {
  set_has_wpn_state();
  if (wpn_state_ == NULL) wpn_state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponHungEventMsg.wpn_state)
  return wpn_state_;
}
inline ::mixr::recorder::pb::PlayerState* WeaponHungEventMsg::release_wpn_state() {
  clear_has_wpn_state();
  ::mixr::recorder::pb::PlayerState* temp = wpn_state_;
  wpn_state_ = NULL;
  return temp;
}
inline void WeaponHungEventMsg::set_allocated_wpn_state(::mixr::recorder::pb::PlayerState* wpn_state) {
  delete wpn_state_;
  wpn_state_ = wpn_state;
  if (wpn_state) {
    set_has_wpn_state();
  } else {
    clear_has_wpn_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponHungEventMsg.wpn_state)
}

// optional .mixr.recorder.pb.PlayerId shooter_id = 3;
inline bool WeaponHungEventMsg::has_shooter_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponHungEventMsg::set_has_shooter_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponHungEventMsg::clear_has_shooter_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponHungEventMsg::clear_shooter_id() {
  if (shooter_id_ != NULL) shooter_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_shooter_id();
}
inline const ::mixr::recorder::pb::PlayerId& WeaponHungEventMsg::shooter_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponHungEventMsg.shooter_id)
  return shooter_id_ != NULL ? *shooter_id_ : *default_instance_->shooter_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponHungEventMsg::mutable_shooter_id() {
  set_has_shooter_id();
  if (shooter_id_ == NULL) shooter_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponHungEventMsg.shooter_id)
  return shooter_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponHungEventMsg::release_shooter_id() {
  clear_has_shooter_id();
  ::mixr::recorder::pb::PlayerId* temp = shooter_id_;
  shooter_id_ = NULL;
  return temp;
}
inline void WeaponHungEventMsg::set_allocated_shooter_id(::mixr::recorder::pb::PlayerId* shooter_id) {
  delete shooter_id_;
  shooter_id_ = shooter_id;
  if (shooter_id) {
    set_has_shooter_id();
  } else {
    clear_has_shooter_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponHungEventMsg.shooter_id)
}

// optional .mixr.recorder.pb.PlayerId tgt_id = 4;
inline bool WeaponHungEventMsg::has_tgt_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeaponHungEventMsg::set_has_tgt_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeaponHungEventMsg::clear_has_tgt_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeaponHungEventMsg::clear_tgt_id() {
  if (tgt_id_ != NULL) tgt_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_tgt_id();
}
inline const ::mixr::recorder::pb::PlayerId& WeaponHungEventMsg::tgt_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponHungEventMsg.tgt_id)
  return tgt_id_ != NULL ? *tgt_id_ : *default_instance_->tgt_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponHungEventMsg::mutable_tgt_id() {
  set_has_tgt_id();
  if (tgt_id_ == NULL) tgt_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponHungEventMsg.tgt_id)
  return tgt_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponHungEventMsg::release_tgt_id() {
  clear_has_tgt_id();
  ::mixr::recorder::pb::PlayerId* temp = tgt_id_;
  tgt_id_ = NULL;
  return temp;
}
inline void WeaponHungEventMsg::set_allocated_tgt_id(::mixr::recorder::pb::PlayerId* tgt_id) {
  delete tgt_id_;
  tgt_id_ = tgt_id;
  if (tgt_id) {
    set_has_tgt_id();
  } else {
    clear_has_tgt_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponHungEventMsg.tgt_id)
}

// -------------------------------------------------------------------

// WeaponDetonationEventMsg

// required .mixr.recorder.pb.PlayerId wpn_id = 1;
inline bool WeaponDetonationEventMsg::has_wpn_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_wpn_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponDetonationEventMsg::clear_has_wpn_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponDetonationEventMsg::clear_wpn_id() {
  if (wpn_id_ != NULL) wpn_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_wpn_id();
}
inline const ::mixr::recorder::pb::PlayerId& WeaponDetonationEventMsg::wpn_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponDetonationEventMsg.wpn_id)
  return wpn_id_ != NULL ? *wpn_id_ : *default_instance_->wpn_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponDetonationEventMsg::mutable_wpn_id() {
  set_has_wpn_id();
  if (wpn_id_ == NULL) wpn_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponDetonationEventMsg.wpn_id)
  return wpn_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponDetonationEventMsg::release_wpn_id() {
  clear_has_wpn_id();
  ::mixr::recorder::pb::PlayerId* temp = wpn_id_;
  wpn_id_ = NULL;
  return temp;
}
inline void WeaponDetonationEventMsg::set_allocated_wpn_id(::mixr::recorder::pb::PlayerId* wpn_id) {
  delete wpn_id_;
  wpn_id_ = wpn_id;
  if (wpn_id) {
    set_has_wpn_id();
  } else {
    clear_has_wpn_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponDetonationEventMsg.wpn_id)
}

// optional .mixr.recorder.pb.PlayerState wpn_state = 2;
inline bool WeaponDetonationEventMsg::has_wpn_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_wpn_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponDetonationEventMsg::clear_has_wpn_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponDetonationEventMsg::clear_wpn_state() {
  if (wpn_state_ != NULL) wpn_state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_wpn_state();
}
inline const ::mixr::recorder::pb::PlayerState& WeaponDetonationEventMsg::wpn_state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponDetonationEventMsg.wpn_state)
  return wpn_state_ != NULL ? *wpn_state_ : *default_instance_->wpn_state_;
}
inline ::mixr::recorder::pb::PlayerState* WeaponDetonationEventMsg::mutable_wpn_state() {
  set_has_wpn_state();
  if (wpn_state_ == NULL) wpn_state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponDetonationEventMsg.wpn_state)
  return wpn_state_;
}
inline ::mixr::recorder::pb::PlayerState* WeaponDetonationEventMsg::release_wpn_state() {
  clear_has_wpn_state();
  ::mixr::recorder::pb::PlayerState* temp = wpn_state_;
  wpn_state_ = NULL;
  return temp;
}
inline void WeaponDetonationEventMsg::set_allocated_wpn_state(::mixr::recorder::pb::PlayerState* wpn_state) {
  delete wpn_state_;
  wpn_state_ = wpn_state;
  if (wpn_state) {
    set_has_wpn_state();
  } else {
    clear_has_wpn_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponDetonationEventMsg.wpn_state)
}

// optional .mixr.recorder.pb.PlayerId shooter_id = 3;
inline bool WeaponDetonationEventMsg::has_shooter_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_shooter_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponDetonationEventMsg::clear_has_shooter_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponDetonationEventMsg::clear_shooter_id() {
  if (shooter_id_ != NULL) shooter_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_shooter_id();
}
inline const ::mixr::recorder::pb::PlayerId& WeaponDetonationEventMsg::shooter_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponDetonationEventMsg.shooter_id)
  return shooter_id_ != NULL ? *shooter_id_ : *default_instance_->shooter_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponDetonationEventMsg::mutable_shooter_id() {
  set_has_shooter_id();
  if (shooter_id_ == NULL) shooter_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponDetonationEventMsg.shooter_id)
  return shooter_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponDetonationEventMsg::release_shooter_id() {
  clear_has_shooter_id();
  ::mixr::recorder::pb::PlayerId* temp = shooter_id_;
  shooter_id_ = NULL;
  return temp;
}
inline void WeaponDetonationEventMsg::set_allocated_shooter_id(::mixr::recorder::pb::PlayerId* shooter_id) {
  delete shooter_id_;
  shooter_id_ = shooter_id;
  if (shooter_id) {
    set_has_shooter_id();
  } else {
    clear_has_shooter_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponDetonationEventMsg.shooter_id)
}

// optional .mixr.recorder.pb.PlayerId tgt_id = 4;
inline bool WeaponDetonationEventMsg::has_tgt_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_tgt_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeaponDetonationEventMsg::clear_has_tgt_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeaponDetonationEventMsg::clear_tgt_id() {
  if (tgt_id_ != NULL) tgt_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_tgt_id();
}
inline const ::mixr::recorder::pb::PlayerId& WeaponDetonationEventMsg::tgt_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponDetonationEventMsg.tgt_id)
  return tgt_id_ != NULL ? *tgt_id_ : *default_instance_->tgt_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponDetonationEventMsg::mutable_tgt_id() {
  set_has_tgt_id();
  if (tgt_id_ == NULL) tgt_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.WeaponDetonationEventMsg.tgt_id)
  return tgt_id_;
}
inline ::mixr::recorder::pb::PlayerId* WeaponDetonationEventMsg::release_tgt_id() {
  clear_has_tgt_id();
  ::mixr::recorder::pb::PlayerId* temp = tgt_id_;
  tgt_id_ = NULL;
  return temp;
}
inline void WeaponDetonationEventMsg::set_allocated_tgt_id(::mixr::recorder::pb::PlayerId* tgt_id) {
  delete tgt_id_;
  tgt_id_ = tgt_id;
  if (tgt_id) {
    set_has_tgt_id();
  } else {
    clear_has_tgt_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.WeaponDetonationEventMsg.tgt_id)
}

// optional .mixr.recorder.pb.WeaponDetonationEventMsg.DetonationType det_type = 5;
inline bool WeaponDetonationEventMsg::has_det_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_det_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WeaponDetonationEventMsg::clear_has_det_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WeaponDetonationEventMsg::clear_det_type() {
  det_type_ = 0;
  clear_has_det_type();
}
inline ::mixr::recorder::pb::WeaponDetonationEventMsg_DetonationType WeaponDetonationEventMsg::det_type() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponDetonationEventMsg.det_type)
  return static_cast< ::mixr::recorder::pb::WeaponDetonationEventMsg_DetonationType >(det_type_);
}
inline void WeaponDetonationEventMsg::set_det_type(::mixr::recorder::pb::WeaponDetonationEventMsg_DetonationType value) {
  assert(::mixr::recorder::pb::WeaponDetonationEventMsg_DetonationType_IsValid(value));
  set_has_det_type();
  det_type_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.WeaponDetonationEventMsg.det_type)
}

// optional double miss_dist = 6;
inline bool WeaponDetonationEventMsg::has_miss_dist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WeaponDetonationEventMsg::set_has_miss_dist() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WeaponDetonationEventMsg::clear_has_miss_dist() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WeaponDetonationEventMsg::clear_miss_dist() {
  miss_dist_ = 0;
  clear_has_miss_dist();
}
inline double WeaponDetonationEventMsg::miss_dist() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.WeaponDetonationEventMsg.miss_dist)
  return miss_dist_;
}
inline void WeaponDetonationEventMsg::set_miss_dist(double value) {
  set_has_miss_dist();
  miss_dist_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.WeaponDetonationEventMsg.miss_dist)
}

// -------------------------------------------------------------------

// GunFiredEventMsg

// required .mixr.recorder.pb.PlayerId shooter_id = 1;
inline bool GunFiredEventMsg::has_shooter_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GunFiredEventMsg::set_has_shooter_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GunFiredEventMsg::clear_has_shooter_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GunFiredEventMsg::clear_shooter_id() {
  if (shooter_id_ != NULL) shooter_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_shooter_id();
}
inline const ::mixr::recorder::pb::PlayerId& GunFiredEventMsg::shooter_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.GunFiredEventMsg.shooter_id)
  return shooter_id_ != NULL ? *shooter_id_ : *default_instance_->shooter_id_;
}
inline ::mixr::recorder::pb::PlayerId* GunFiredEventMsg::mutable_shooter_id() {
  set_has_shooter_id();
  if (shooter_id_ == NULL) shooter_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.GunFiredEventMsg.shooter_id)
  return shooter_id_;
}
inline ::mixr::recorder::pb::PlayerId* GunFiredEventMsg::release_shooter_id() {
  clear_has_shooter_id();
  ::mixr::recorder::pb::PlayerId* temp = shooter_id_;
  shooter_id_ = NULL;
  return temp;
}
inline void GunFiredEventMsg::set_allocated_shooter_id(::mixr::recorder::pb::PlayerId* shooter_id) {
  delete shooter_id_;
  shooter_id_ = shooter_id;
  if (shooter_id) {
    set_has_shooter_id();
  } else {
    clear_has_shooter_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.GunFiredEventMsg.shooter_id)
}

// optional uint32 rounds = 2;
inline bool GunFiredEventMsg::has_rounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GunFiredEventMsg::set_has_rounds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GunFiredEventMsg::clear_has_rounds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GunFiredEventMsg::clear_rounds() {
  rounds_ = 0u;
  clear_has_rounds();
}
inline ::google::protobuf::uint32 GunFiredEventMsg::rounds() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.GunFiredEventMsg.rounds)
  return rounds_;
}
inline void GunFiredEventMsg::set_rounds(::google::protobuf::uint32 value) {
  set_has_rounds();
  rounds_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.GunFiredEventMsg.rounds)
}

// -------------------------------------------------------------------

// NewTrackEventMsg

// required .mixr.recorder.pb.PlayerId player_id = 1;
inline bool NewTrackEventMsg::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewTrackEventMsg::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewTrackEventMsg::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewTrackEventMsg::clear_player_id() {
  if (player_id_ != NULL) player_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_player_id();
}
inline const ::mixr::recorder::pb::PlayerId& NewTrackEventMsg::player_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.NewTrackEventMsg.player_id)
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::mixr::recorder::pb::PlayerId* NewTrackEventMsg::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.NewTrackEventMsg.player_id)
  return player_id_;
}
inline ::mixr::recorder::pb::PlayerId* NewTrackEventMsg::release_player_id() {
  clear_has_player_id();
  ::mixr::recorder::pb::PlayerId* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void NewTrackEventMsg::set_allocated_player_id(::mixr::recorder::pb::PlayerId* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.NewTrackEventMsg.player_id)
}

// required string track_id = 2;
inline bool NewTrackEventMsg::has_track_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewTrackEventMsg::set_has_track_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewTrackEventMsg::clear_has_track_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewTrackEventMsg::clear_track_id() {
  if (track_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_->clear();
  }
  clear_has_track_id();
}
inline const ::std::string& NewTrackEventMsg::track_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.NewTrackEventMsg.track_id)
  return *track_id_;
}
inline void NewTrackEventMsg::set_track_id(const ::std::string& value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.NewTrackEventMsg.track_id)
}
inline void NewTrackEventMsg::set_track_id(const char* value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mixr.recorder.pb.NewTrackEventMsg.track_id)
}
inline void NewTrackEventMsg::set_track_id(const char* value, size_t size) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mixr.recorder.pb.NewTrackEventMsg.track_id)
}
inline ::std::string* NewTrackEventMsg::mutable_track_id() {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.NewTrackEventMsg.track_id)
  return track_id_;
}
inline ::std::string* NewTrackEventMsg::release_track_id() {
  clear_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = track_id_;
    track_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewTrackEventMsg::set_allocated_track_id(::std::string* track_id) {
  if (track_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete track_id_;
  }
  if (track_id) {
    set_has_track_id();
    track_id_ = track_id;
  } else {
    clear_has_track_id();
    track_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.NewTrackEventMsg.track_id)
}

// optional .mixr.recorder.pb.TrackData track_data = 3;
inline bool NewTrackEventMsg::has_track_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewTrackEventMsg::set_has_track_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewTrackEventMsg::clear_has_track_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewTrackEventMsg::clear_track_data() {
  if (track_data_ != NULL) track_data_->::mixr::recorder::pb::TrackData::Clear();
  clear_has_track_data();
}
inline const ::mixr::recorder::pb::TrackData& NewTrackEventMsg::track_data() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.NewTrackEventMsg.track_data)
  return track_data_ != NULL ? *track_data_ : *default_instance_->track_data_;
}
inline ::mixr::recorder::pb::TrackData* NewTrackEventMsg::mutable_track_data() {
  set_has_track_data();
  if (track_data_ == NULL) track_data_ = new ::mixr::recorder::pb::TrackData;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.NewTrackEventMsg.track_data)
  return track_data_;
}
inline ::mixr::recorder::pb::TrackData* NewTrackEventMsg::release_track_data() {
  clear_has_track_data();
  ::mixr::recorder::pb::TrackData* temp = track_data_;
  track_data_ = NULL;
  return temp;
}
inline void NewTrackEventMsg::set_allocated_track_data(::mixr::recorder::pb::TrackData* track_data) {
  delete track_data_;
  track_data_ = track_data;
  if (track_data) {
    set_has_track_data();
  } else {
    clear_has_track_data();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.NewTrackEventMsg.track_data)
}

// optional .mixr.recorder.pb.PlayerState player_state = 4;
inline bool NewTrackEventMsg::has_player_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewTrackEventMsg::set_has_player_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewTrackEventMsg::clear_has_player_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewTrackEventMsg::clear_player_state() {
  if (player_state_ != NULL) player_state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_player_state();
}
inline const ::mixr::recorder::pb::PlayerState& NewTrackEventMsg::player_state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.NewTrackEventMsg.player_state)
  return player_state_ != NULL ? *player_state_ : *default_instance_->player_state_;
}
inline ::mixr::recorder::pb::PlayerState* NewTrackEventMsg::mutable_player_state() {
  set_has_player_state();
  if (player_state_ == NULL) player_state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.NewTrackEventMsg.player_state)
  return player_state_;
}
inline ::mixr::recorder::pb::PlayerState* NewTrackEventMsg::release_player_state() {
  clear_has_player_state();
  ::mixr::recorder::pb::PlayerState* temp = player_state_;
  player_state_ = NULL;
  return temp;
}
inline void NewTrackEventMsg::set_allocated_player_state(::mixr::recorder::pb::PlayerState* player_state) {
  delete player_state_;
  player_state_ = player_state;
  if (player_state) {
    set_has_player_state();
  } else {
    clear_has_player_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.NewTrackEventMsg.player_state)
}

// optional .mixr.recorder.pb.PlayerId trk_player_id = 5;
inline bool NewTrackEventMsg::has_trk_player_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewTrackEventMsg::set_has_trk_player_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewTrackEventMsg::clear_has_trk_player_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewTrackEventMsg::clear_trk_player_id() {
  if (trk_player_id_ != NULL) trk_player_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_trk_player_id();
}
inline const ::mixr::recorder::pb::PlayerId& NewTrackEventMsg::trk_player_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.NewTrackEventMsg.trk_player_id)
  return trk_player_id_ != NULL ? *trk_player_id_ : *default_instance_->trk_player_id_;
}
inline ::mixr::recorder::pb::PlayerId* NewTrackEventMsg::mutable_trk_player_id() {
  set_has_trk_player_id();
  if (trk_player_id_ == NULL) trk_player_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.NewTrackEventMsg.trk_player_id)
  return trk_player_id_;
}
inline ::mixr::recorder::pb::PlayerId* NewTrackEventMsg::release_trk_player_id() {
  clear_has_trk_player_id();
  ::mixr::recorder::pb::PlayerId* temp = trk_player_id_;
  trk_player_id_ = NULL;
  return temp;
}
inline void NewTrackEventMsg::set_allocated_trk_player_id(::mixr::recorder::pb::PlayerId* trk_player_id) {
  delete trk_player_id_;
  trk_player_id_ = trk_player_id;
  if (trk_player_id) {
    set_has_trk_player_id();
  } else {
    clear_has_trk_player_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.NewTrackEventMsg.trk_player_id)
}

// optional .mixr.recorder.pb.PlayerState trk_player_state = 6;
inline bool NewTrackEventMsg::has_trk_player_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewTrackEventMsg::set_has_trk_player_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewTrackEventMsg::clear_has_trk_player_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewTrackEventMsg::clear_trk_player_state() {
  if (trk_player_state_ != NULL) trk_player_state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_trk_player_state();
}
inline const ::mixr::recorder::pb::PlayerState& NewTrackEventMsg::trk_player_state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.NewTrackEventMsg.trk_player_state)
  return trk_player_state_ != NULL ? *trk_player_state_ : *default_instance_->trk_player_state_;
}
inline ::mixr::recorder::pb::PlayerState* NewTrackEventMsg::mutable_trk_player_state() {
  set_has_trk_player_state();
  if (trk_player_state_ == NULL) trk_player_state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.NewTrackEventMsg.trk_player_state)
  return trk_player_state_;
}
inline ::mixr::recorder::pb::PlayerState* NewTrackEventMsg::release_trk_player_state() {
  clear_has_trk_player_state();
  ::mixr::recorder::pb::PlayerState* temp = trk_player_state_;
  trk_player_state_ = NULL;
  return temp;
}
inline void NewTrackEventMsg::set_allocated_trk_player_state(::mixr::recorder::pb::PlayerState* trk_player_state) {
  delete trk_player_state_;
  trk_player_state_ = trk_player_state;
  if (trk_player_state) {
    set_has_trk_player_state();
  } else {
    clear_has_trk_player_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.NewTrackEventMsg.trk_player_state)
}

// optional .mixr.recorder.pb.EmissionData emission_data = 7;
inline bool NewTrackEventMsg::has_emission_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewTrackEventMsg::set_has_emission_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewTrackEventMsg::clear_has_emission_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewTrackEventMsg::clear_emission_data() {
  if (emission_data_ != NULL) emission_data_->::mixr::recorder::pb::EmissionData::Clear();
  clear_has_emission_data();
}
inline const ::mixr::recorder::pb::EmissionData& NewTrackEventMsg::emission_data() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.NewTrackEventMsg.emission_data)
  return emission_data_ != NULL ? *emission_data_ : *default_instance_->emission_data_;
}
inline ::mixr::recorder::pb::EmissionData* NewTrackEventMsg::mutable_emission_data() {
  set_has_emission_data();
  if (emission_data_ == NULL) emission_data_ = new ::mixr::recorder::pb::EmissionData;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.NewTrackEventMsg.emission_data)
  return emission_data_;
}
inline ::mixr::recorder::pb::EmissionData* NewTrackEventMsg::release_emission_data() {
  clear_has_emission_data();
  ::mixr::recorder::pb::EmissionData* temp = emission_data_;
  emission_data_ = NULL;
  return temp;
}
inline void NewTrackEventMsg::set_allocated_emission_data(::mixr::recorder::pb::EmissionData* emission_data) {
  delete emission_data_;
  emission_data_ = emission_data;
  if (emission_data) {
    set_has_emission_data();
  } else {
    clear_has_emission_data();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.NewTrackEventMsg.emission_data)
}

// -------------------------------------------------------------------

// TrackRemovedEventMsg

// required .mixr.recorder.pb.PlayerId player_id = 1;
inline bool TrackRemovedEventMsg::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackRemovedEventMsg::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackRemovedEventMsg::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackRemovedEventMsg::clear_player_id() {
  if (player_id_ != NULL) player_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_player_id();
}
inline const ::mixr::recorder::pb::PlayerId& TrackRemovedEventMsg::player_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackRemovedEventMsg.player_id)
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::mixr::recorder::pb::PlayerId* TrackRemovedEventMsg::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackRemovedEventMsg.player_id)
  return player_id_;
}
inline ::mixr::recorder::pb::PlayerId* TrackRemovedEventMsg::release_player_id() {
  clear_has_player_id();
  ::mixr::recorder::pb::PlayerId* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void TrackRemovedEventMsg::set_allocated_player_id(::mixr::recorder::pb::PlayerId* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackRemovedEventMsg.player_id)
}

// required string track_id = 2;
inline bool TrackRemovedEventMsg::has_track_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackRemovedEventMsg::set_has_track_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackRemovedEventMsg::clear_has_track_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackRemovedEventMsg::clear_track_id() {
  if (track_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_->clear();
  }
  clear_has_track_id();
}
inline const ::std::string& TrackRemovedEventMsg::track_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackRemovedEventMsg.track_id)
  return *track_id_;
}
inline void TrackRemovedEventMsg::set_track_id(const ::std::string& value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackRemovedEventMsg.track_id)
}
inline void TrackRemovedEventMsg::set_track_id(const char* value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mixr.recorder.pb.TrackRemovedEventMsg.track_id)
}
inline void TrackRemovedEventMsg::set_track_id(const char* value, size_t size) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mixr.recorder.pb.TrackRemovedEventMsg.track_id)
}
inline ::std::string* TrackRemovedEventMsg::mutable_track_id() {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackRemovedEventMsg.track_id)
  return track_id_;
}
inline ::std::string* TrackRemovedEventMsg::release_track_id() {
  clear_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = track_id_;
    track_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TrackRemovedEventMsg::set_allocated_track_id(::std::string* track_id) {
  if (track_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete track_id_;
  }
  if (track_id) {
    set_has_track_id();
    track_id_ = track_id;
  } else {
    clear_has_track_id();
    track_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackRemovedEventMsg.track_id)
}

// -------------------------------------------------------------------

// TrackDataMsg

// required .mixr.recorder.pb.PlayerId player_id = 1;
inline bool TrackDataMsg::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackDataMsg::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackDataMsg::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackDataMsg::clear_player_id() {
  if (player_id_ != NULL) player_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_player_id();
}
inline const ::mixr::recorder::pb::PlayerId& TrackDataMsg::player_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackDataMsg.player_id)
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::mixr::recorder::pb::PlayerId* TrackDataMsg::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackDataMsg.player_id)
  return player_id_;
}
inline ::mixr::recorder::pb::PlayerId* TrackDataMsg::release_player_id() {
  clear_has_player_id();
  ::mixr::recorder::pb::PlayerId* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void TrackDataMsg::set_allocated_player_id(::mixr::recorder::pb::PlayerId* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackDataMsg.player_id)
}

// required string track_id = 2;
inline bool TrackDataMsg::has_track_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackDataMsg::set_has_track_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackDataMsg::clear_has_track_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackDataMsg::clear_track_id() {
  if (track_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_->clear();
  }
  clear_has_track_id();
}
inline const ::std::string& TrackDataMsg::track_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackDataMsg.track_id)
  return *track_id_;
}
inline void TrackDataMsg::set_track_id(const ::std::string& value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackDataMsg.track_id)
}
inline void TrackDataMsg::set_track_id(const char* value) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mixr.recorder.pb.TrackDataMsg.track_id)
}
inline void TrackDataMsg::set_track_id(const char* value, size_t size) {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  track_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mixr.recorder.pb.TrackDataMsg.track_id)
}
inline ::std::string* TrackDataMsg::mutable_track_id() {
  set_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    track_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackDataMsg.track_id)
  return track_id_;
}
inline ::std::string* TrackDataMsg::release_track_id() {
  clear_has_track_id();
  if (track_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = track_id_;
    track_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TrackDataMsg::set_allocated_track_id(::std::string* track_id) {
  if (track_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete track_id_;
  }
  if (track_id) {
    set_has_track_id();
    track_id_ = track_id;
  } else {
    clear_has_track_id();
    track_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackDataMsg.track_id)
}

// optional .mixr.recorder.pb.TrackData track_data = 3;
inline bool TrackDataMsg::has_track_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackDataMsg::set_has_track_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackDataMsg::clear_has_track_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackDataMsg::clear_track_data() {
  if (track_data_ != NULL) track_data_->::mixr::recorder::pb::TrackData::Clear();
  clear_has_track_data();
}
inline const ::mixr::recorder::pb::TrackData& TrackDataMsg::track_data() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackDataMsg.track_data)
  return track_data_ != NULL ? *track_data_ : *default_instance_->track_data_;
}
inline ::mixr::recorder::pb::TrackData* TrackDataMsg::mutable_track_data() {
  set_has_track_data();
  if (track_data_ == NULL) track_data_ = new ::mixr::recorder::pb::TrackData;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackDataMsg.track_data)
  return track_data_;
}
inline ::mixr::recorder::pb::TrackData* TrackDataMsg::release_track_data() {
  clear_has_track_data();
  ::mixr::recorder::pb::TrackData* temp = track_data_;
  track_data_ = NULL;
  return temp;
}
inline void TrackDataMsg::set_allocated_track_data(::mixr::recorder::pb::TrackData* track_data) {
  delete track_data_;
  track_data_ = track_data;
  if (track_data) {
    set_has_track_data();
  } else {
    clear_has_track_data();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackDataMsg.track_data)
}

// optional .mixr.recorder.pb.PlayerState player_state = 4;
inline bool TrackDataMsg::has_player_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackDataMsg::set_has_player_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackDataMsg::clear_has_player_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackDataMsg::clear_player_state() {
  if (player_state_ != NULL) player_state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_player_state();
}
inline const ::mixr::recorder::pb::PlayerState& TrackDataMsg::player_state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackDataMsg.player_state)
  return player_state_ != NULL ? *player_state_ : *default_instance_->player_state_;
}
inline ::mixr::recorder::pb::PlayerState* TrackDataMsg::mutable_player_state() {
  set_has_player_state();
  if (player_state_ == NULL) player_state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackDataMsg.player_state)
  return player_state_;
}
inline ::mixr::recorder::pb::PlayerState* TrackDataMsg::release_player_state() {
  clear_has_player_state();
  ::mixr::recorder::pb::PlayerState* temp = player_state_;
  player_state_ = NULL;
  return temp;
}
inline void TrackDataMsg::set_allocated_player_state(::mixr::recorder::pb::PlayerState* player_state) {
  delete player_state_;
  player_state_ = player_state;
  if (player_state) {
    set_has_player_state();
  } else {
    clear_has_player_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackDataMsg.player_state)
}

// optional .mixr.recorder.pb.PlayerId trk_player_id = 5;
inline bool TrackDataMsg::has_trk_player_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrackDataMsg::set_has_trk_player_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrackDataMsg::clear_has_trk_player_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrackDataMsg::clear_trk_player_id() {
  if (trk_player_id_ != NULL) trk_player_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_trk_player_id();
}
inline const ::mixr::recorder::pb::PlayerId& TrackDataMsg::trk_player_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackDataMsg.trk_player_id)
  return trk_player_id_ != NULL ? *trk_player_id_ : *default_instance_->trk_player_id_;
}
inline ::mixr::recorder::pb::PlayerId* TrackDataMsg::mutable_trk_player_id() {
  set_has_trk_player_id();
  if (trk_player_id_ == NULL) trk_player_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackDataMsg.trk_player_id)
  return trk_player_id_;
}
inline ::mixr::recorder::pb::PlayerId* TrackDataMsg::release_trk_player_id() {
  clear_has_trk_player_id();
  ::mixr::recorder::pb::PlayerId* temp = trk_player_id_;
  trk_player_id_ = NULL;
  return temp;
}
inline void TrackDataMsg::set_allocated_trk_player_id(::mixr::recorder::pb::PlayerId* trk_player_id) {
  delete trk_player_id_;
  trk_player_id_ = trk_player_id;
  if (trk_player_id) {
    set_has_trk_player_id();
  } else {
    clear_has_trk_player_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackDataMsg.trk_player_id)
}

// optional .mixr.recorder.pb.PlayerState trk_player_state = 6;
inline bool TrackDataMsg::has_trk_player_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrackDataMsg::set_has_trk_player_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrackDataMsg::clear_has_trk_player_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrackDataMsg::clear_trk_player_state() {
  if (trk_player_state_ != NULL) trk_player_state_->::mixr::recorder::pb::PlayerState::Clear();
  clear_has_trk_player_state();
}
inline const ::mixr::recorder::pb::PlayerState& TrackDataMsg::trk_player_state() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackDataMsg.trk_player_state)
  return trk_player_state_ != NULL ? *trk_player_state_ : *default_instance_->trk_player_state_;
}
inline ::mixr::recorder::pb::PlayerState* TrackDataMsg::mutable_trk_player_state() {
  set_has_trk_player_state();
  if (trk_player_state_ == NULL) trk_player_state_ = new ::mixr::recorder::pb::PlayerState;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackDataMsg.trk_player_state)
  return trk_player_state_;
}
inline ::mixr::recorder::pb::PlayerState* TrackDataMsg::release_trk_player_state() {
  clear_has_trk_player_state();
  ::mixr::recorder::pb::PlayerState* temp = trk_player_state_;
  trk_player_state_ = NULL;
  return temp;
}
inline void TrackDataMsg::set_allocated_trk_player_state(::mixr::recorder::pb::PlayerState* trk_player_state) {
  delete trk_player_state_;
  trk_player_state_ = trk_player_state;
  if (trk_player_state) {
    set_has_trk_player_state();
  } else {
    clear_has_trk_player_state();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackDataMsg.trk_player_state)
}

// optional .mixr.recorder.pb.EmissionData emission_data = 7;
inline bool TrackDataMsg::has_emission_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrackDataMsg::set_has_emission_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrackDataMsg::clear_has_emission_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrackDataMsg::clear_emission_data() {
  if (emission_data_ != NULL) emission_data_->::mixr::recorder::pb::EmissionData::Clear();
  clear_has_emission_data();
}
inline const ::mixr::recorder::pb::EmissionData& TrackDataMsg::emission_data() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackDataMsg.emission_data)
  return emission_data_ != NULL ? *emission_data_ : *default_instance_->emission_data_;
}
inline ::mixr::recorder::pb::EmissionData* TrackDataMsg::mutable_emission_data() {
  set_has_emission_data();
  if (emission_data_ == NULL) emission_data_ = new ::mixr::recorder::pb::EmissionData;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackDataMsg.emission_data)
  return emission_data_;
}
inline ::mixr::recorder::pb::EmissionData* TrackDataMsg::release_emission_data() {
  clear_has_emission_data();
  ::mixr::recorder::pb::EmissionData* temp = emission_data_;
  emission_data_ = NULL;
  return temp;
}
inline void TrackDataMsg::set_allocated_emission_data(::mixr::recorder::pb::EmissionData* emission_data) {
  delete emission_data_;
  emission_data_ = emission_data;
  if (emission_data) {
    set_has_emission_data();
  } else {
    clear_has_emission_data();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackDataMsg.emission_data)
}

// -------------------------------------------------------------------

// Vector

// required double x = 1;
inline bool Vector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector::x() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.Vector.x)
  return x_;
}
inline void Vector::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.Vector.x)
}

// required double y = 2;
inline bool Vector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector::y() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.Vector.y)
  return y_;
}
inline void Vector::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.Vector.y)
}

// optional double z = 3;
inline bool Vector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector::z() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.Vector.z)
  return z_;
}
inline void Vector::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.Vector.z)
}

// optional double w = 4;
inline bool Vector::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vector::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vector::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vector::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Vector::w() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.Vector.w)
  return w_;
}
inline void Vector::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.Vector.w)
}

// -------------------------------------------------------------------

// Time

// required double sim_time = 1;
inline bool Time::has_sim_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_sim_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_sim_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_sim_time() {
  sim_time_ = 0;
  clear_has_sim_time();
}
inline double Time::sim_time() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.Time.sim_time)
  return sim_time_;
}
inline void Time::set_sim_time(double value) {
  set_has_sim_time();
  sim_time_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.Time.sim_time)
}

// optional double exec_time = 2;
inline bool Time::has_exec_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_exec_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_exec_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_exec_time() {
  exec_time_ = 0;
  clear_has_exec_time();
}
inline double Time::exec_time() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.Time.exec_time)
  return exec_time_;
}
inline void Time::set_exec_time(double value) {
  set_has_exec_time();
  exec_time_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.Time.exec_time)
}

// optional double utc_time = 3;
inline bool Time::has_utc_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Time::set_has_utc_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Time::clear_has_utc_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Time::clear_utc_time() {
  utc_time_ = 0;
  clear_has_utc_time();
}
inline double Time::utc_time() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.Time.utc_time)
  return utc_time_;
}
inline void Time::set_utc_time(double value) {
  set_has_utc_time();
  utc_time_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.Time.utc_time)
}

// -------------------------------------------------------------------

// PlayerId

// required uint32 id = 1;
inline bool PlayerId::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerId::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerId::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerId::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 PlayerId::id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerId.id)
  return id_;
}
inline void PlayerId::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.PlayerId.id)
}

// optional string name = 2;
inline bool PlayerId::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerId::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerId::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerId::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayerId::name() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerId.name)
  return *name_;
}
inline void PlayerId::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.PlayerId.name)
}
inline void PlayerId::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mixr.recorder.pb.PlayerId.name)
}
inline void PlayerId::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mixr.recorder.pb.PlayerId.name)
}
inline ::std::string* PlayerId::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerId.name)
  return name_;
}
inline ::std::string* PlayerId::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerId::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerId.name)
}

// optional string fed_name = 3;
inline bool PlayerId::has_fed_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerId::set_has_fed_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerId::clear_has_fed_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerId::clear_fed_name() {
  if (fed_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fed_name_->clear();
  }
  clear_has_fed_name();
}
inline const ::std::string& PlayerId::fed_name() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerId.fed_name)
  return *fed_name_;
}
inline void PlayerId::set_fed_name(const ::std::string& value) {
  set_has_fed_name();
  if (fed_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fed_name_ = new ::std::string;
  }
  fed_name_->assign(value);
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.PlayerId.fed_name)
}
inline void PlayerId::set_fed_name(const char* value) {
  set_has_fed_name();
  if (fed_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fed_name_ = new ::std::string;
  }
  fed_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mixr.recorder.pb.PlayerId.fed_name)
}
inline void PlayerId::set_fed_name(const char* value, size_t size) {
  set_has_fed_name();
  if (fed_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fed_name_ = new ::std::string;
  }
  fed_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mixr.recorder.pb.PlayerId.fed_name)
}
inline ::std::string* PlayerId::mutable_fed_name() {
  set_has_fed_name();
  if (fed_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fed_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerId.fed_name)
  return fed_name_;
}
inline ::std::string* PlayerId::release_fed_name() {
  clear_has_fed_name();
  if (fed_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fed_name_;
    fed_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerId::set_allocated_fed_name(::std::string* fed_name) {
  if (fed_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fed_name_;
  }
  if (fed_name) {
    set_has_fed_name();
    fed_name_ = fed_name;
  } else {
    clear_has_fed_name();
    fed_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerId.fed_name)
}

// optional uint32 side = 4;
inline bool PlayerId::has_side() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerId::set_has_side() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerId::clear_has_side() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerId::clear_side() {
  side_ = 0u;
  clear_has_side();
}
inline ::google::protobuf::uint32 PlayerId::side() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerId.side)
  return side_;
}
inline void PlayerId::set_side(::google::protobuf::uint32 value) {
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.PlayerId.side)
}

// optional uint32 major_type = 5;
inline bool PlayerId::has_major_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerId::set_has_major_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerId::clear_has_major_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerId::clear_major_type() {
  major_type_ = 0u;
  clear_has_major_type();
}
inline ::google::protobuf::uint32 PlayerId::major_type() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerId.major_type)
  return major_type_;
}
inline void PlayerId::set_major_type(::google::protobuf::uint32 value) {
  set_has_major_type();
  major_type_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.PlayerId.major_type)
}

// optional string ac_type = 6;
inline bool PlayerId::has_ac_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerId::set_has_ac_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerId::clear_has_ac_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerId::clear_ac_type() {
  if (ac_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ac_type_->clear();
  }
  clear_has_ac_type();
}
inline const ::std::string& PlayerId::ac_type() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerId.ac_type)
  return *ac_type_;
}
inline void PlayerId::set_ac_type(const ::std::string& value) {
  set_has_ac_type();
  if (ac_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ac_type_ = new ::std::string;
  }
  ac_type_->assign(value);
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.PlayerId.ac_type)
}
inline void PlayerId::set_ac_type(const char* value) {
  set_has_ac_type();
  if (ac_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ac_type_ = new ::std::string;
  }
  ac_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mixr.recorder.pb.PlayerId.ac_type)
}
inline void PlayerId::set_ac_type(const char* value, size_t size) {
  set_has_ac_type();
  if (ac_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ac_type_ = new ::std::string;
  }
  ac_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mixr.recorder.pb.PlayerId.ac_type)
}
inline ::std::string* PlayerId::mutable_ac_type() {
  set_has_ac_type();
  if (ac_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ac_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerId.ac_type)
  return ac_type_;
}
inline ::std::string* PlayerId::release_ac_type() {
  clear_has_ac_type();
  if (ac_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ac_type_;
    ac_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerId::set_allocated_ac_type(::std::string* ac_type) {
  if (ac_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ac_type_;
  }
  if (ac_type) {
    set_has_ac_type();
    ac_type_ = ac_type;
  } else {
    clear_has_ac_type();
    ac_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerId.ac_type)
}

// -------------------------------------------------------------------

// PlayerState

// required .mixr.recorder.pb.Vector pos = 1;
inline bool PlayerState::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerState::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerState::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerState::clear_pos() {
  if (pos_ != NULL) pos_->::mixr::recorder::pb::Vector::Clear();
  clear_has_pos();
}
inline const ::mixr::recorder::pb::Vector& PlayerState::pos() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerState.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::mixr::recorder::pb::Vector* PlayerState::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::mixr::recorder::pb::Vector;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerState.pos)
  return pos_;
}
inline ::mixr::recorder::pb::Vector* PlayerState::release_pos() {
  clear_has_pos();
  ::mixr::recorder::pb::Vector* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void PlayerState::set_allocated_pos(::mixr::recorder::pb::Vector* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerState.pos)
}

// required .mixr.recorder.pb.Vector angles = 2;
inline bool PlayerState::has_angles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerState::set_has_angles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerState::clear_has_angles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerState::clear_angles() {
  if (angles_ != NULL) angles_->::mixr::recorder::pb::Vector::Clear();
  clear_has_angles();
}
inline const ::mixr::recorder::pb::Vector& PlayerState::angles() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerState.angles)
  return angles_ != NULL ? *angles_ : *default_instance_->angles_;
}
inline ::mixr::recorder::pb::Vector* PlayerState::mutable_angles() {
  set_has_angles();
  if (angles_ == NULL) angles_ = new ::mixr::recorder::pb::Vector;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerState.angles)
  return angles_;
}
inline ::mixr::recorder::pb::Vector* PlayerState::release_angles() {
  clear_has_angles();
  ::mixr::recorder::pb::Vector* temp = angles_;
  angles_ = NULL;
  return temp;
}
inline void PlayerState::set_allocated_angles(::mixr::recorder::pb::Vector* angles) {
  delete angles_;
  angles_ = angles;
  if (angles) {
    set_has_angles();
  } else {
    clear_has_angles();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerState.angles)
}

// optional .mixr.recorder.pb.Vector vel = 3;
inline bool PlayerState::has_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerState::set_has_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerState::clear_has_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerState::clear_vel() {
  if (vel_ != NULL) vel_->::mixr::recorder::pb::Vector::Clear();
  clear_has_vel();
}
inline const ::mixr::recorder::pb::Vector& PlayerState::vel() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerState.vel)
  return vel_ != NULL ? *vel_ : *default_instance_->vel_;
}
inline ::mixr::recorder::pb::Vector* PlayerState::mutable_vel() {
  set_has_vel();
  if (vel_ == NULL) vel_ = new ::mixr::recorder::pb::Vector;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.PlayerState.vel)
  return vel_;
}
inline ::mixr::recorder::pb::Vector* PlayerState::release_vel() {
  clear_has_vel();
  ::mixr::recorder::pb::Vector* temp = vel_;
  vel_ = NULL;
  return temp;
}
inline void PlayerState::set_allocated_vel(::mixr::recorder::pb::Vector* vel) {
  delete vel_;
  vel_ = vel;
  if (vel) {
    set_has_vel();
  } else {
    clear_has_vel();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.PlayerState.vel)
}

// optional double damage = 4;
inline bool PlayerState::has_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerState::set_has_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerState::clear_has_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerState::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline double PlayerState::damage() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.PlayerState.damage)
  return damage_;
}
inline void PlayerState::set_damage(double value) {
  set_has_damage();
  damage_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.PlayerState.damage)
}

// -------------------------------------------------------------------

// TrackData

// optional uint32 type = 1;
inline bool TrackData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 TrackData::type() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.type)
  return type_;
}
inline void TrackData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.type)
}

// optional double quality = 2;
inline bool TrackData::has_quality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackData::set_has_quality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackData::clear_has_quality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackData::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline double TrackData::quality() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.quality)
  return quality_;
}
inline void TrackData::set_quality(double value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.quality)
}

// optional double true_az = 3;
inline bool TrackData::has_true_az() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackData::set_has_true_az() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackData::clear_has_true_az() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackData::clear_true_az() {
  true_az_ = 0;
  clear_has_true_az();
}
inline double TrackData::true_az() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.true_az)
  return true_az_;
}
inline void TrackData::set_true_az(double value) {
  set_has_true_az();
  true_az_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.true_az)
}

// optional double rel_az = 4;
inline bool TrackData::has_rel_az() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackData::set_has_rel_az() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackData::clear_has_rel_az() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackData::clear_rel_az() {
  rel_az_ = 0;
  clear_has_rel_az();
}
inline double TrackData::rel_az() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.rel_az)
  return rel_az_;
}
inline void TrackData::set_rel_az(double value) {
  set_has_rel_az();
  rel_az_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.rel_az)
}

// optional double elevation = 5;
inline bool TrackData::has_elevation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrackData::set_has_elevation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrackData::clear_has_elevation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrackData::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline double TrackData::elevation() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.elevation)
  return elevation_;
}
inline void TrackData::set_elevation(double value) {
  set_has_elevation();
  elevation_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.elevation)
}

// optional double range = 6;
inline bool TrackData::has_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrackData::set_has_range() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrackData::clear_has_range() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrackData::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline double TrackData::range() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.range)
  return range_;
}
inline void TrackData::set_range(double value) {
  set_has_range();
  range_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.range)
}

// optional double latitude = 7;
inline bool TrackData::has_latitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrackData::set_has_latitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrackData::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrackData::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double TrackData::latitude() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.latitude)
  return latitude_;
}
inline void TrackData::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.latitude)
}

// optional double longitude = 8;
inline bool TrackData::has_longitude() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrackData::set_has_longitude() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrackData::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrackData::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double TrackData::longitude() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.longitude)
  return longitude_;
}
inline void TrackData::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.longitude)
}

// optional double altitude = 9;
inline bool TrackData::has_altitude() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrackData::set_has_altitude() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrackData::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrackData::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double TrackData::altitude() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.altitude)
  return altitude_;
}
inline void TrackData::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.altitude)
}

// optional .mixr.recorder.pb.Vector position = 10;
inline bool TrackData::has_position() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TrackData::set_has_position() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TrackData::clear_has_position() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TrackData::clear_position() {
  if (position_ != NULL) position_->::mixr::recorder::pb::Vector::Clear();
  clear_has_position();
}
inline const ::mixr::recorder::pb::Vector& TrackData::position() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::mixr::recorder::pb::Vector* TrackData::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::mixr::recorder::pb::Vector;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackData.position)
  return position_;
}
inline ::mixr::recorder::pb::Vector* TrackData::release_position() {
  clear_has_position();
  ::mixr::recorder::pb::Vector* temp = position_;
  position_ = NULL;
  return temp;
}
inline void TrackData::set_allocated_position(::mixr::recorder::pb::Vector* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackData.position)
}

// optional .mixr.recorder.pb.Vector velocity = 11;
inline bool TrackData::has_velocity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TrackData::set_has_velocity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TrackData::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TrackData::clear_velocity() {
  if (velocity_ != NULL) velocity_->::mixr::recorder::pb::Vector::Clear();
  clear_has_velocity();
}
inline const ::mixr::recorder::pb::Vector& TrackData::velocity() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::mixr::recorder::pb::Vector* TrackData::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::mixr::recorder::pb::Vector;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.TrackData.velocity)
  return velocity_;
}
inline ::mixr::recorder::pb::Vector* TrackData::release_velocity() {
  clear_has_velocity();
  ::mixr::recorder::pb::Vector* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void TrackData::set_allocated_velocity(::mixr::recorder::pb::Vector* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.TrackData.velocity)
}

// optional double avg_signal = 12;
inline bool TrackData::has_avg_signal() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TrackData::set_has_avg_signal() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TrackData::clear_has_avg_signal() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TrackData::clear_avg_signal() {
  avg_signal_ = 0;
  clear_has_avg_signal();
}
inline double TrackData::avg_signal() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.avg_signal)
  return avg_signal_;
}
inline void TrackData::set_avg_signal(double value) {
  set_has_avg_signal();
  avg_signal_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.avg_signal)
}

// optional uint32 sl_index = 13;
inline bool TrackData::has_sl_index() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TrackData::set_has_sl_index() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TrackData::clear_has_sl_index() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TrackData::clear_sl_index() {
  sl_index_ = 0u;
  clear_has_sl_index();
}
inline ::google::protobuf::uint32 TrackData::sl_index() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.sl_index)
  return sl_index_;
}
inline void TrackData::set_sl_index(::google::protobuf::uint32 value) {
  set_has_sl_index();
  sl_index_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.sl_index)
}

// optional bool wpn_rel = 14;
inline bool TrackData::has_wpn_rel() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TrackData::set_has_wpn_rel() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TrackData::clear_has_wpn_rel() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TrackData::clear_wpn_rel() {
  wpn_rel_ = false;
  clear_has_wpn_rel();
}
inline bool TrackData::wpn_rel() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.TrackData.wpn_rel)
  return wpn_rel_;
}
inline void TrackData::set_wpn_rel(bool value) {
  set_has_wpn_rel();
  wpn_rel_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.TrackData.wpn_rel)
}

// -------------------------------------------------------------------

// EmissionData

// optional double frequency = 1;
inline bool EmissionData::has_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmissionData::set_has_frequency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmissionData::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmissionData::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline double EmissionData::frequency() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.frequency)
  return frequency_;
}
inline void EmissionData::set_frequency(double value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.EmissionData.frequency)
}

// optional double wave_length = 2;
inline bool EmissionData::has_wave_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmissionData::set_has_wave_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmissionData::clear_has_wave_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmissionData::clear_wave_length() {
  wave_length_ = 0;
  clear_has_wave_length();
}
inline double EmissionData::wave_length() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.wave_length)
  return wave_length_;
}
inline void EmissionData::set_wave_length(double value) {
  set_has_wave_length();
  wave_length_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.EmissionData.wave_length)
}

// optional double pulse_width = 3;
inline bool EmissionData::has_pulse_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmissionData::set_has_pulse_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmissionData::clear_has_pulse_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmissionData::clear_pulse_width() {
  pulse_width_ = 0;
  clear_has_pulse_width();
}
inline double EmissionData::pulse_width() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.pulse_width)
  return pulse_width_;
}
inline void EmissionData::set_pulse_width(double value) {
  set_has_pulse_width();
  pulse_width_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.EmissionData.pulse_width)
}

// optional double bandwidth = 4;
inline bool EmissionData::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmissionData::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmissionData::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmissionData::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double EmissionData::bandwidth() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.bandwidth)
  return bandwidth_;
}
inline void EmissionData::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.EmissionData.bandwidth)
}

// optional double prf = 5;
inline bool EmissionData::has_prf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmissionData::set_has_prf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmissionData::clear_has_prf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmissionData::clear_prf() {
  prf_ = 0;
  clear_has_prf();
}
inline double EmissionData::prf() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.prf)
  return prf_;
}
inline void EmissionData::set_prf(double value) {
  set_has_prf();
  prf_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.EmissionData.prf)
}

// optional double power = 6;
inline bool EmissionData::has_power() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmissionData::set_has_power() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmissionData::clear_has_power() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmissionData::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline double EmissionData::power() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.power)
  return power_;
}
inline void EmissionData::set_power(double value) {
  set_has_power();
  power_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.EmissionData.power)
}

// optional .mixr.recorder.pb.EmissionData.Polarization polarization = 7;
inline bool EmissionData::has_polarization() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmissionData::set_has_polarization() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmissionData::clear_has_polarization() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmissionData::clear_polarization() {
  polarization_ = 0;
  clear_has_polarization();
}
inline ::mixr::recorder::pb::EmissionData_Polarization EmissionData::polarization() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.polarization)
  return static_cast< ::mixr::recorder::pb::EmissionData_Polarization >(polarization_);
}
inline void EmissionData::set_polarization(::mixr::recorder::pb::EmissionData_Polarization value) {
  assert(::mixr::recorder::pb::EmissionData_Polarization_IsValid(value));
  set_has_polarization();
  polarization_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.EmissionData.polarization)
}

// optional double azimuth_aoi = 8;
inline bool EmissionData::has_azimuth_aoi() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmissionData::set_has_azimuth_aoi() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmissionData::clear_has_azimuth_aoi() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmissionData::clear_azimuth_aoi() {
  azimuth_aoi_ = 0;
  clear_has_azimuth_aoi();
}
inline double EmissionData::azimuth_aoi() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.azimuth_aoi)
  return azimuth_aoi_;
}
inline void EmissionData::set_azimuth_aoi(double value) {
  set_has_azimuth_aoi();
  azimuth_aoi_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.EmissionData.azimuth_aoi)
}

// optional double elevation_aoi = 9;
inline bool EmissionData::has_elevation_aoi() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmissionData::set_has_elevation_aoi() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmissionData::clear_has_elevation_aoi() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmissionData::clear_elevation_aoi() {
  elevation_aoi_ = 0;
  clear_has_elevation_aoi();
}
inline double EmissionData::elevation_aoi() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.elevation_aoi)
  return elevation_aoi_;
}
inline void EmissionData::set_elevation_aoi(double value) {
  set_has_elevation_aoi();
  elevation_aoi_ = value;
  // @@protoc_insertion_point(field_set:mixr.recorder.pb.EmissionData.elevation_aoi)
}

// optional .mixr.recorder.pb.PlayerId origin_id = 10;
inline bool EmissionData::has_origin_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmissionData::set_has_origin_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmissionData::clear_has_origin_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmissionData::clear_origin_id() {
  if (origin_id_ != NULL) origin_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_origin_id();
}
inline const ::mixr::recorder::pb::PlayerId& EmissionData::origin_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.origin_id)
  return origin_id_ != NULL ? *origin_id_ : *default_instance_->origin_id_;
}
inline ::mixr::recorder::pb::PlayerId* EmissionData::mutable_origin_id() {
  set_has_origin_id();
  if (origin_id_ == NULL) origin_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.EmissionData.origin_id)
  return origin_id_;
}
inline ::mixr::recorder::pb::PlayerId* EmissionData::release_origin_id() {
  clear_has_origin_id();
  ::mixr::recorder::pb::PlayerId* temp = origin_id_;
  origin_id_ = NULL;
  return temp;
}
inline void EmissionData::set_allocated_origin_id(::mixr::recorder::pb::PlayerId* origin_id) {
  delete origin_id_;
  origin_id_ = origin_id;
  if (origin_id) {
    set_has_origin_id();
  } else {
    clear_has_origin_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.EmissionData.origin_id)
}

// optional .mixr.recorder.pb.PlayerId target_id = 11;
inline bool EmissionData::has_target_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EmissionData::set_has_target_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EmissionData::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EmissionData::clear_target_id() {
  if (target_id_ != NULL) target_id_->::mixr::recorder::pb::PlayerId::Clear();
  clear_has_target_id();
}
inline const ::mixr::recorder::pb::PlayerId& EmissionData::target_id() const {
  // @@protoc_insertion_point(field_get:mixr.recorder.pb.EmissionData.target_id)
  return target_id_ != NULL ? *target_id_ : *default_instance_->target_id_;
}
inline ::mixr::recorder::pb::PlayerId* EmissionData::mutable_target_id() {
  set_has_target_id();
  if (target_id_ == NULL) target_id_ = new ::mixr::recorder::pb::PlayerId;
  // @@protoc_insertion_point(field_mutable:mixr.recorder.pb.EmissionData.target_id)
  return target_id_;
}
inline ::mixr::recorder::pb::PlayerId* EmissionData::release_target_id() {
  clear_has_target_id();
  ::mixr::recorder::pb::PlayerId* temp = target_id_;
  target_id_ = NULL;
  return temp;
}
inline void EmissionData::set_allocated_target_id(::mixr::recorder::pb::PlayerId* target_id) {
  delete target_id_;
  target_id_ = target_id;
  if (target_id) {
    set_has_target_id();
  } else {
    clear_has_target_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mixr.recorder.pb.EmissionData.target_id)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace recorder
}  // namespace mixr

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mixr::recorder::pb::WeaponDetonationEventMsg_DetonationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mixr::recorder::pb::WeaponDetonationEventMsg_DetonationType>() {
  return ::mixr::recorder::pb::WeaponDetonationEventMsg_DetonationType_descriptor();
}
template <> struct is_proto_enum< ::mixr::recorder::pb::EmissionData_Polarization> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mixr::recorder::pb::EmissionData_Polarization>() {
  return ::mixr::recorder::pb::EmissionData_Polarization_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mixr_2frecorder_2fprotobuf_2fDataRecord_2eproto__INCLUDED
